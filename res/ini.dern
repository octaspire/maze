(define level                      as '()                              [level])
(define pass-counters              as (hash-map)                       [pass counters of the level])
(define level-width                as 20                               [level-width])
(define level-hwidth               as (to-integer (* level-width 0.5)) [level half width])
(define level-current-number       as nil                              [current level number])
(define level-number-of-keys       as 0                                [How many keys current level had when it started])
(define player-x                   as nil                              [current player x])
(define player-y                   as nil                              [current player y])
(define level-updatable-indices    as (hash-map)                       [entities in current level that must be updated])
(define pass-or-fail-level-pending as false                            [.])
(define active-exit-x              as nil                              [x-coordinate of activated exit])
(define active-exit-y              as nil                              [y-coordinate of activated exit])
(define level-restart-pending      as -1                               [Negative: not pending])

(define get-player as (fn ()
    (level-get-slot player-x player-y))
  [.] '() howto-no)

(define make-empty-slot as (fn ()
    (hash-map
         'name []
         'x    0
         'y    0
         'dir  nil
         'count 0
         'bomb-original-count 0
         'bomb-started false
         'bomb-uptime 0
         'number-of-keys 0
         'player-was-on-side  []
         'toggle-e false
         'toggle-n false
         'toggle-s false
         'toggle-w false
         'decreasePending false
         'removePending false))
  [make empty slot] '() howto-no)

(define level-init as (fn ()
    (for i from 0 to (* level-width level-width) (+= level (make-empty-slot))))
  [init level] '() howto-no)

(level-init)

(define level-reset as (fn ()
    (animation-entity-remove-all)
    (= pending-input '())
    (= level-updatable-indices (hash-map))
    (= level-number-of-keys 0)
    (= player-x nil)
    (= player-y nil)
    (= pass-or-fail-level-pending false)
    (= active-exit-x nil)
    (= active-exit-y nil)
    (for i in level (= i 'name []))
    (= pass-counters (hash-map)))
  [clear level] '() howto-no)

(define coordinates-to-index as (fn (x y)
    (+ (+ x level-hwidth) (* (+ y level-hwidth) level-width)))
  [...] '(x [x] y [y]) howto-ok)

(define level-set-slot as (fn (x y slot)
    (= (ln@ level (coordinates-to-index x y)) slot))
  [level-set-slot] '(x [x] y [y] slot [slot]) howto-no)

(define level-set-slot-to-empty as (fn (x y)
    (= (level-get-slot x y) 'name []))
  [level-set-slot] '(x [x] y [y]) howto-no)

(define level-get-slot as (fn (x y)
    (ln@ level (coordinates-to-index x y)))
  [level-get-slot] '(x [x] y [y]) howto-no)

(define level-is-slot-empty? as (fn (x y)
    (== [] (find (level-get-slot x y) 'name)))
  [level-is-slot-empty?] '(x [x] y [y]) howto-no)


(define level-move-slot as (fn (fx fy tx ty)
    (level-set-slot tx ty (level-get-slot fx fy))
    (level-set-slot-to-empty fx fy)
    (= (level-get-slot tx ty) 'x tx)
    (= (level-get-slot tx ty) 'y ty))
  [level-move-slot] '(fx [fx] fy [fy] tx [tx] ty [ty]) howto-no)

(define are-coordinates-out-of-level as (fn (x y)
    (select
        (< x (- level-hwidth))  true
        (>= x level-hwidth)     true
        (< y (- level-hwidth))  true
        (>= y level-hwidth)     true
        default                 false))
  [check if coordinates are outside level area] '(x [x] y [y]) howto-ok)

(define dir-to-side as (fn (dir)
    (select
        (== dir [u]) [d]
        (== dir [d]) [u]
        (== dir [l]) [r]
        (== dir [r]) [l]
        default      nil))
  [dir-to-side] '(dir [dir]) howto-ok)

(define coords-to-side as (fn (ex ey px py)
    (if (== ex px)
        (if (== ey py) (return nil) (if (> ey py) (return [d]) (return [u]))))

    (if (== ey py)
        (if (== ex px) (return nil) (if (> ex px) (return [r]) (return [l]))))

    nil)
  [coords-to-side] '(ex [ex] ey [ey] px [px] py [py]) howto-ok)

(define bomb-remove as (fn (name x y)
    (level-set-slot-to-empty x y)
    (animation-entity-remove name)
    (-= level-updatable-indices name) 
    nil)
  [remove the named bomb at the given coordinates] '(name [name] x [x] y [y]) howto-no)

(define bomb-on-collision as (fn (name x y)
    (define slot as (level-get-slot x y) [slot at x y, the bomb])
    (if (find slot 'bomb-started) (bomb-remove name x y) (= slot 'bomb-started true)))
  [should be called when bomb has collision with player]
  '(name [bomb's name] x [bomb's x] y [bomb's y]) howto-no)

(define toggle-open? as (fn (slot)
    (select
        (== (find slot 'toggle-e) false) true
        (== (find slot 'toggle-n) false) true
        (== (find slot 'toggle-s) false) true
        (== (find slot 'toggle-w) false) true
        default                          false))
  [...] '(slot [slot]) howto-no)

(define toggle-set-correct-animation as (fn (name x y)
    (define slot as (level-get-slot x y) [slot at x y, the toggle])

    (define e as (find slot 'toggle-e) [e])
    (define n as (find slot 'toggle-n) [e])
    (define s as (find slot 'toggle-s) [e])
    (define w as (find slot 'toggle-w) [e])

    (select
        ; 1 none
        (and (not e) (not n) (not s) (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-none-idle] '((* 16 x) (* 16 y) 0)))

        ; 2 east
        (and e (not n) (not s) (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-e-idle] '((* 16 x) (* 16 y) 0)))

        ; 3 north
        (and (not e) n (not s) (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-n-idle] '((* 16 x) (* 16 y) 0)))

        ; 4 east and north
        (and e n (not s) (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-en-idle] '((* 16 x) (* 16 y) 0)))

        ; 5 south only
        (and (not e) (not n) s (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-s-idle] '((* 16 x) (* 16 y) 0)))

        ; 6 es
        (and e (not n) s (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-es-idle] '((* 16 x) (* 16 y) 0)))

        ; 7 ns
        (and (not e) n s (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-ns-idle] '((* 16 x) (* 16 y) 0)))

        ; 8 ens
        (and e n s (not w)) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-ens-idle] '((* 16 x) (* 16 y) 0)))

        ; 9 w
        (and (not e) (not n) (not s) w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-w-idle] '((* 16 x) (* 16 y) 0)))

        ; 10 ew
        (and e (not n) (not s) w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-ew-idle] '((* 16 x) (* 16 y) 0)))

        ; 11 nw
        (and (not e) n (not s) w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-nw-idle] '((* 16 x) (* 16 y) 0)))

        ; 12 enw
        (and e n (not s) w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-enw-idle] '((* 16 x) (* 16 y) 0)))

        ; 13 sw
        (and (not e) (not n) s w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-sw-idle] '((* 16 x) (* 16 y) 0)))

        ; 14 esw
        (and e (not n) s w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-esw-idle] '((* 16 x) (* 16 y) 0)))

        ; 15 nsw
        (and (not e) n s w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-nsw-idle] '((* 16 x) (* 16 y) 0)))

        ; 16 ensw
        (and e n s w) (do
            (animation-entity-remove name)
            (animation-entity-new name [toggle-ensw-idle] '((* 16 x) (* 16 y) 0)))))

  [...] '(name [name] x [x] y [y]) howto-no)

(define toggle-on-collision as (fn (name x y pdir)
    (define slot as (level-get-slot x y) [slot at x y, the toggle])

    (select
        (== pdir [u]) (do (= slot 'toggle-s true) (toggle-set-correct-animation name x y))
        (== pdir [d]) (do (= slot 'toggle-n true) (toggle-set-correct-animation name x y))
        (== pdir [l]) (do (= slot 'toggle-e true) (toggle-set-correct-animation name x y))
        (== pdir [r]) (do (= slot 'toggle-w true) (toggle-set-correct-animation name x y))))

  [should be called when toggle has collision with player]
  '(name [toggle's name] x [toggle's x] y [toggle's y] pdir [player's dir]) howto-no)

(define stop-counter-remove as (fn (name x y)
    (level-set-slot-to-empty x y)
    (animation-entity-remove name))
  [remove the named stop counter at the given coordinates]
  '(name [name] x [x] y [y]) howto-no)

(define get-player-num-keys as (fn ()
    (find (get-player) 'number-of-keys))
  [.] '() howto-no)

(define set-player-dir as (fn (dir)
    (= (get-player) 'dir dir))
  [.] '(dir [dir]) howto-no)

(define get-player-current-pullable-id as (fn ()
    (find (get-player) 'current-pullable-id))
  [.] '() howto-no)

(define stop-counter-on-collision as (fn (name x y)
    (define slot  as (level-get-slot x y) [slot at x y, the counter])
    (define count as (find slot 'count)   [count before collision])
    (if (== count 1) (do (stop-counter-remove name x y) (return nil)))
    (define animationName as (string-format [stop-counter-{}] count) [name of the animation])
    (animation-entity-remove name)
    (-= count 1)
    (define animationName as (string-format [stop-counter-{}] count) [name of the animation])
    (animation-entity-new name animationName '((* 16 x) (* 16 y) 0))
    (= slot 'count count))
  [should be called when stop counter has collision with player]
  '(name [counter's name] x [counter's x] y [counter's y]) howto-no)

(define key-on-collision as (fn (name x y)
    (level-set-slot-to-empty x y)
    (animation-entity-remove name)
    (= (get-player) 'number-of-keys (++ (find (get-player) 'number-of-keys))))
  [should be called when key has collision with player]
  '(name [key's name] x [key's x] y [key's y]) howto-no)

(define turnstile-ew-on-collision as (fn (name x y pdir)
    (define fx as (+ x 1) [fx])
    (define fy as y [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as (- x 1) [tx])
    (define ty as y       [ty])
    (move-player-to tx ty)
    (= (get-player) 'dir pdir))
  [should be called when turnstile-ew has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define turnstile-we-on-collision as (fn (name x y pdir)
    (define fx as (- x 1) [fx])
    (define fy as y       [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as (+ x 1) [tx])
    (define ty as y       [ty])
    (move-player-to tx ty)
    (= (get-player) 'dir pdir))
  [should be called when turnstile-we has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define turnstile-sn-on-collision as (fn (name x y pdir)
    (define fx as x       [fx])
    (define fy as (+ y 1) [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as x       [tx])
    (define ty as (- y 1) [ty])
    (move-player-to tx ty)
    (= (get-player) 'dir pdir))
  [should be called when turnstile-sn has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define turnstile-ns-on-collision as (fn (name x y pdir)
    (define fx as x       [fx])
    (define fy as (- y 1) [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as x       [tx])
    (define ty as (+ y 1) [ty])
    (move-player-to tx ty)
    (= (get-player) 'dir pdir))
  [should be called when turnstile-ns has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)



(define stop-turnstile-ew-on-collision as (fn (name x y pdir)
    (define fx as (+ x 1) [fx])
    (define fy as y       [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as (- x 1) [tx])
    (define ty as y       [ty])
    (move-player-to tx ty))
  [should be called when stop-turnstile-ew has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define stop-turnstile-we-on-collision as (fn (name x y pdir)
    (define fx as (- x 1) [fx])
    (define fy as y       [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as (+ x 1) [tx])
    (define ty as y       [ty])
    (move-player-to tx ty))
  [should be called when stop-turnstile-we has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define stop-turnstile-sn-on-collision as (fn (name x y pdir)
    (define fx as x       [fx])
    (define fy as (+ y 1) [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as x       [tx])
    (define ty as (- y 1) [ty])
    (move-player-to tx ty))
  [should be called when stop-turnstile-sn has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)

(define stop-turnstile-ns-on-collision as (fn (name x y pdir)
    (define fx as x       [fx])
    (define fy as (- y 1) [fy])
    (if (!= fx player-x) (return nil))
    (if (!= fy player-y) (return nil))
    (define tx as x       [tx])
    (define ty as (+ y 1) [ty])
    (move-player-to tx ty))
  [should be called when stop-turnstile-ns has collision with player]
  '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir])
  howto-no)






(define slope-en-on-collision as (fn (name x y pdir)
    (define fx1 as x       [fx1])
    (define fy1 as (- y 1) [fy1])
    (define fx2 as (+ x 1) [fx2])
    (define fy2 as y       [fy2])
    (define tx1 as fx2     [tx1])
    (define ty1 as fy2     [ty1])
    (define tx2 as fx1     [tx2])
    (define ty2 as fy1     [ty2])
    (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [r]) (return nil)))
    (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [u]) (return nil))))
  [should be called when slope-en has collision with player]
  '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir])
  howto-no)

(define slope-es-on-collision as (fn (name x y pdir)
    (define fx1 as x       [fx1])
    (define fy1 as (+ y 1) [fy1])
    (define fx2 as (+ x 1) [fx2])
    (define fy2 as y       [fy2])
    (define tx1 as fx2     [tx1])
    (define ty1 as fy2     [ty1])
    (define tx2 as fx1     [tx2])
    (define ty2 as fy1     [ty2])
    (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [r]) (return nil)))
    (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [d]) (return nil))))
  [should be called when slope-es has collision with player]
  '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) howto-no)

(define slope-nw-on-collision as (fn (name x y pdir)
    (define fx1 as x       [fx1])
    (define fy1 as (- y 1) [fy1])
    (define fx2 as (- x 1) [fx2])
    (define fy2 as y       [fy2])
    (define tx1 as fx2     [tx1])
    (define ty1 as fy2     [ty1])
    (define tx2 as fx1     [tx2])
    (define ty2 as fy1     [ty2])
    (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [l]) (return nil)))
    (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [u]) (return nil))))
  [should be called when slope-nw has collision with player]
  '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) howto-no)

(define slope-sw-on-collision as (fn (name x y pdir)
    (define fx1 as x       [fx1])
    (define fy1 as (+ y 1) [fy1])
    (define fx2 as (- x 1) [fx2])
    (define fy2 as y       [fy2])
    (define tx1 as fx2     [tx1])
    (define ty1 as fy2     [ty1])
    (define tx2 as fx1     [tx2])
    (define ty2 as fy1     [ty2])
    (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [l]) (return nil)))
    (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [d]) (return nil))))
  [should be called when slope-sw has collision with player]
  '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) howto-no)

(define exit-change-to-animation as (fn (x y name)
    (if (or (nil? x) (nil? y)) return)
    (animation-entity-remove (find (level-get-slot x y) 'name))
    (define id as (string-format [exit-{}-{}] x y) [id])
    (animation-entity-new id name '((* 16 x) (* 16 y) 0)))
  [Make exit to show the named animation]
  '(x [x of exit] y [y of exit] name [name of animation to show]) howto-no)

(define pass-or-fail-level as (fn ()
    (animation-entity-remove (find (level-get-slot player-x player-y) 'name))

    (if (< (find (get-player) 'number-of-keys) level-number-of-keys)
      (do
        (exit-change-to-animation active-exit-x active-exit-y [exit-fail])
        (= level-restart-pending 10)
        (return nil)))

    (for slot in level
         (if (starts-with? (find slot 'name) [toggle])
           (if (toggle-open? slot)
             (do
               (exit-change-to-animation active-exit-x active-exit-y [exit-fail])
               (= level-restart-pending 10)
               (return nil)))))

    ; Level is passed
    (exit-change-to-animation active-exit-x active-exit-y [exit-pass])
    (= current-state [tweenOut])
    (tween-level-out))
  [Move to next level or restart current] '() howto-no)

(define on-collision as (fn (tx ty dir)
    (define slot as (level-get-slot tx ty) [slot at tx ty, the thing collided with])
    (define name as (find slot 'name) [name])

    (define side as (dir-to-side dir) [on which side is player of the target])

    (select
        (starts-with? name [exit])              (do (= active-exit-x tx) (= active-exit-y ty) (= pass-or-fail-level-pending true))
        (starts-with? name [pullable])          (pullable-on-collision name slot side)
        (starts-with? name [stop-counter])      (stop-counter-on-collision name tx ty)
        (starts-with? name [bomb])              (bomb-on-collision name tx ty)
        (starts-with? name [toggle])            (toggle-on-collision name tx ty dir)
        (starts-with? name [key])               (do (key-on-collision name tx ty) (set-player-dir dir))
        (starts-with? name [turnstile-ew])      (turnstile-ew-on-collision name tx ty dir)
        (starts-with? name [turnstile-we])      (turnstile-we-on-collision name tx ty dir)
        (starts-with? name [turnstile-sn])      (turnstile-sn-on-collision name tx ty dir)
        (starts-with? name [turnstile-ns])      (turnstile-ns-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-ew]) (stop-turnstile-ew-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-we]) (stop-turnstile-we-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-sn]) (stop-turnstile-sn-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-ns]) (stop-turnstile-ns-on-collision name tx ty dir)
        (starts-with? name [slope-en])          (slope-en-on-collision name tx ty dir)
        (starts-with? name [slope-es])          (slope-es-on-collision name tx ty dir)
        (starts-with? name [slope-nw])          (slope-nw-on-collision name tx ty dir)
        (starts-with? name [slope-sw])          (slope-sw-on-collision name tx ty dir)))
  [on-collision] '(tx [tx] ty [ty] dir [player's direction]) howto-no)

(define pullable-on-collision as (fn (name slot side)

    (select
        (starts-with? name [pullable-ensw-]) nil ; NOP
        (starts-with? name [pullable-e-])   (if (not (== side [r])) (return))
        (starts-with? name [pullable-en-])  (if (not (or (== side [r]) (== side [u]))) (return))
        (starts-with? name [pullable-ens-]) (if (not (or (== side [r]) (== side [u]) (== side [d]))) (return))
        (starts-with? name [pullable-enw-]) (if (not (or (== side [r]) (== side [u]) (== side [l]))) (return))
        (starts-with? name [pullable-es-])  (if (not (or (== side [r]) (== side [d]))) (return))
        (starts-with? name [pullable-esw-]) (if (not (or (== side [r]) (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-ew-])  (if (not (or (== side [r]) (== side [l]))) (return))
        (starts-with? name [pullable-n-])   (if (not (== side [u])) (return))
        (starts-with? name [pullable-ns-])  (if (not (or (== side [u]) (== side [d]))) (return))
        (starts-with? name [pullable-nsw-]) (if (not (or (== side [u]) (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-nw-])  (if (not (or (== side [u]) (== side [l]))) (return))
        (starts-with? name [pullable-s-])   (if (not (or (== side [d]))) (return))
        (starts-with? name [pullable-sw-])  (if (not (or (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-w-])   (if (not (or (== side [l]))) (return)))

    (do
        (ensure-pullable-in-updatables  name slot)
        (= slot 'player-was-on-side side)))
  [...] '(name [name] slot [slot] side [side]) howto-no)

(define ensure-pullable-in-updatables as (fn (name slot)
    (for i in level-updatable-indices (if (== (ln@ i 0) name) (return nil)))
    (+= level-updatable-indices name slot))
  [...] '(name [name] slot [slot]) howto-no)

(define move-pullable-from-to as (fn (fx fy tx ty)

    (define from-slot as (level-get-slot fx fy) [slot at fx fy])

    (if (not (starts-with? (find from-slot 'name) [pullable-])) (abort [pullable expected]))

    (define to-slot as (level-get-slot tx ty) [slot at tx ty])

    (if (== [] (find to-slot 'name))
        (do (level-move-slot fx fy tx ty)
            (= level-updatable-indices (find (level-get-slot tx ty) 'name) (level-get-slot tx ty))
            (animation-entity-set-position (find to-slot 'name)  (vector (* 16 tx) (* 16 ty) 0))
            )))
  [move pullable] '(fx [fx] fy [fy] tx [tx] ty [ty]) howto-no)

(define move-pullable-up as (fn (x y)
    (move-pullable-from-to x y x (- y 1)))
  [...] '(x [x] y [y]) howto-no)

(define move-pullable-down as (fn (x y)
    (move-pullable-from-to x y x (+ y 1)))
  [...] '(x [x] y [y]) howto-no)

(define move-pullable-left as (fn (x y)
    (move-pullable-from-to x y (- x 1) y))
  [...] '(x [x] y [y]) howto-no)

(define move-pullable-right as (fn (x y)
    (move-pullable-from-to x y (+ x 1) y))
  [...] '(x [x] y [y]) howto-no)

(define reverse-side as (fn (side)
    (select 
        (== [u] side) [d]
        (== [d] side) [u]
        (== [l] side) [r]
        (== [r] side) [l]))
  [...] '(side [side to reverse]) howto-ok)

(define move-player-to as (fn (tx ty)
    (if (are-coordinates-out-of-level tx ty)
        (level-restart)
        (if (== [] (find (level-get-slot tx ty) 'name))
            (do
                (level-move-slot player-x player-y tx ty)
                (= player-x tx)
                (= player-y ty)
                (animation-entity-set-position (find (get-player) 'name) (vector (* 16 tx) (* 16 ty) 0)))
             (do
                (define tmpDir as (find (get-player) 'dir) [tmpDir])
                (= (get-player) 'dir nil)
                (on-collision tx ty tmpDir)))))
  [move player] '(tx [tx] ty [ty]) howto-no)

(define entity-new-player as (fn (x y)
     (define id as (string-format [player-{}-{}] x y) [id])
     (animation-entity-new id [player-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (= player-x x)
     (= player-y y)
     (= (get-player) 'name id)
     (= (get-player) 'x    x)
     (= (get-player) 'y    y))
  [entity-new-player] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-wall as (fn (x y)
     (define id as (string-format [wall-{}-{}] x y) [id])
     (animation-entity-new id [wall-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the wall to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-wall] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stopper as (fn (x y)
     (define id as (string-format [stopper-{}-{}] x y) [id])
     (animation-entity-new id [stopper-idle] '((* 16 x) (* 16 y) -1))
     (define slot as (make-empty-slot) [slot at x y, the stopper])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= level-updatable-indices id slot))
  [entity-new-stopper] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-toggle as (fn (x y)
     (define id as (string-format [toggle-{}-{}] x y) [id])
     (animation-entity-new id [toggle-none-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the toggle])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-toggle] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-slope-en as (fn (x y)
     (define id as (string-format [slope-en-{}-{}] x y) [id])
     (animation-entity-new id [slope-en-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the slope-en to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-slope-en] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-slope-es as (fn (x y)
     (define id as (string-format [slope-es-{}-{}] x y) [id])
     (animation-entity-new id [slope-es-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the slope-es to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-slope-es] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-slope-nw as (fn (x y)
     (define id as (string-format [slope-nw-{}-{}] x y) [id])
     (animation-entity-new id [slope-nw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the slope-nw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-slope-nw] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-slope-sw as (fn (x y)
     (define id as (string-format [slope-sw-{}-{}] x y) [id])
     (animation-entity-new id [slope-sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the slope-sw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-slope-sw] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-turnstile-ew as (fn (x y)
     (define id as (string-format [turnstile-ew-{}-{}] x y) [id])
     (animation-entity-new id [turnstile-ew-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the turnstile-ew to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-turnstile-ew] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-turnstile-we as (fn (x y)
     (define id as (string-format [turnstile-we-{}-{}] x y) [id])
     (animation-entity-new id [turnstile-we-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the turnstile-we to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-turnstile-we] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-turnstile-sn as (fn (x y)
     (define id as (string-format [turnstile-sn-{}-{}] x y) [id])
     (animation-entity-new id [turnstile-sn-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the turnstile-sn to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-turnstile-sn] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-turnstile-ns as (fn (x y)
     (define id as (string-format [turnstile-ns-{}-{}] x y) [id])
     (animation-entity-new id [turnstile-ns-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the turnstile-ns to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-turnstile-ns] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stop-turnstile-ew as (fn (x y)
     (define id as (string-format [stop-turnstile-ew-{}-{}] x y) [id])
     (animation-entity-new id [stop-turnstile-ew-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the stop-turnstile-ew to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-stop-turnstile-ew] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stop-turnstile-we as (fn (x y)
     (define id as (string-format [stop-turnstile-we-{}-{}] x y) [id])
     (animation-entity-new id [stop-turnstile-we-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the stop-turnstile-we to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-stop-turnstile-we] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stop-turnstile-sn as (fn (x y)
     (define id as (string-format [stop-turnstile-sn-{}-{}] x y) [id])
     (animation-entity-new id [stop-turnstile-sn-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the stop-turnstile-sn to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-stop-turnstile-sn] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stop-turnstile-ns as (fn (x y)
     (define id as (string-format [stop-turnstile-ns-{}-{}] x y) [id])
     (animation-entity-new id [stop-turnstile-ns-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the stop-turnstile-ns to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-stop-turnstile-ns] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-exit as (fn (x y)
     (define id as (string-format [exit-{}-{}] x y) [id])
     (animation-entity-new id [exit-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the exit to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-exit] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-ensw as (fn (x y)
     (define id as (string-format [pullable-ensw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-ensw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-ensw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to up, down, left and right]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-e as (fn (x y)
     (define id as (string-format [pullable-e-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-e----idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-e to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-en as (fn (x y)
     (define id as (string-format [pullable-en-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-en---idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-en to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right and up]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-ens as (fn (x y)
     (define id as (string-format [pullable-ens-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-ens--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-ens to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right, up and down]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-enw as (fn (x y)
     (define id as (string-format [pullable-enw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-en-w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-enw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right, up and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-es as (fn (x y)
     (define id as (string-format [pullable-es-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-e-s--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-es to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right and down]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-esw as (fn (x y)
     (define id as (string-format [pullable-esw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-e-sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-esw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right, down and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-ew as (fn (x y)
     (define id as (string-format [pullable-ew-{}-{}] x y) [id])
     (animation-entity-new  id [pullable-e--w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-ew to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to right and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-n as (fn (x y)
     (define id as (string-format [pullable-n-{}-{}] x y) [id])
     (animation-entity-new  id [pullable--n---idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-n to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to up]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-ns as (fn (x y)
     (define id as (string-format [pullable-ns-{}-{}] x y) [id])
     (animation-entity-new  id [pullable--ns--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-ns to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to up and down]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-nsw as (fn (x y)
     (define id as (string-format [pullable-nsw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable--nsw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-nsw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to up, down and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-nw as (fn (x y)
     (define id as (string-format [pullable-nw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable--n-w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-nw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to up and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-s as (fn (x y)
     (define id as (string-format [pullable-s-{}-{}] x y) [id])
     (animation-entity-new  id [pullable---s--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-s to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to down]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-sw as (fn (x y)
     (define id as (string-format [pullable-sw-{}-{}] x y) [id])
     (animation-entity-new  id [pullable---sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-sw to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to down and left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-pullable-w as (fn (x y)
     (define id as (string-format [pullable-w-{}-{}] x y) [id])
     (animation-entity-new  id [pullable----w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the pullable-w to be])
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Add entity that can be pulled to left]
  '(x [x-coordinate] y [y-coordinate]) howto-no)

(define entity-new-stop-counter as (fn (x y count)
     (define id as (string-format [stop-counter-{}-{}] x y) [id])
     (animation-entity-new id (string-format [stop-counter-{}] count) '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the stop-counter to be])
     (= slot 'count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [entity-new-stop-counter]
  '(x [x-coordinate] y [y-coordinate] count [current count]) howto-no)

(define entity-new-pass-counter as (fn (x y count)
     (define id as (string-format [pass-counter-{}-{}] x y) [id])
     (animation-entity-new id (string-format [pass-counter-{}] count) '((* 16 x) (* 16 y) 1))
     (define slot as (make-empty-slot) [slot at x y, the pass-counter to be])
     (= slot 'count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= pass-counters id slot))
  [entity-new-pass-counter]
  '(x [x-coordinate] y [y-coordinate] count [current count]) howto-no)

(define pass-counter-decrease as (fn (slot)
    (define x             as (find slot 'x)             [x])
    (define y             as (find slot 'y)             [y])
    (define count         as (find slot 'count)         [count])
    (define name          as (find slot 'name)          [name])
    (define removePending as (find slot 'removePending) [removePending])

    (if removePending (return))

    (if (== 1 count)
        (do
            (= slot 'removePending true)
            (pass-counter-update slot 0)
            (return nil)))

    (-- count)
    (= slot 'count count)
    (= slot 'decreasePending false)

    (animation-entity-remove name)

    (animation-entity-new
        name
        (string-format [pass-counter-{}] count)
        '((* 16 (find slot 'x)) (* 16 (find slot 'y)) 1)))
  [decrease a pass counter] '(slot [slot for the pass counter]) howto-no)

(define pass-counter-update as (fn (slot dt)
    (define x               as (find slot 'x)               [x])
    (define y               as (find slot 'y)               [y])
    (define name            as (find slot 'name)            [name])
    (define decreasePending as (find slot 'decreasePending) [tmp])
    (define removePending   as (find slot 'removePending)   [tmp])

    (if removePending
        (do
            (if (level-is-slot-empty? x y) (do
                (animation-entity-remove name)
                (-= pass-counters name)
                (entity-new-wall x y)))
            (return nil)))

    (if decreasePending
        (do
            (if (or (!= player-x x) (!= player-y y)) (pass-counter-decrease slot))
            (return nil)))

    (if (and (== player-x x) (== player-y y)) (= slot 'decreasePending true)))
  [update a pass counter] '(slot [slot for the pass counter] dt [delta time]) howto-no)

(define entity-new-bomb as (fn (x y count)
     (define id as (string-format [bomb-{}-{}] x y) [id])
     (animation-entity-new id (string-format [bomb-{}] count) '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the bomb to be])
     (= slot 'count count)
     (= slot 'bomb-original-count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= level-updatable-indices id slot))
  [entity-new-bomb] '(x [x-coordinate] y [y-coordinate] count [current count]) howto-no)

(define entity-new-key as (fn (x y)
     (define id as (string-format [key-{}-{}] x y) [id])
     (animation-entity-new id [key-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot as (level-get-slot x y) [slot at x y, the key to be])
     (++ level-number-of-keys)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y))
  [Create new key] '(x [x-coordinate] y [y-coordinate]) howto-no)

(define levels as '(

    ; ========== 1. level ==========
    (fn ()
    ; Top row
    (entity-new-player -6 0)
    (entity-new-exit    6 0))



    ; ========== 2. level ==========
    (fn ()
    ; Top row
    (entity-new-player -6 0)
    (entity-new-key     0 0)
    (entity-new-exit    6 0))



    ; ========== 3. level ==========
    (fn ()
    ; Top row
    (entity-new-wall    -6 0)
    (entity-new-key     -5 0)
    (entity-new-player  -2 0)
    (entity-new-key      0 0)
    (entity-new-exit     6 0))



    ; ========== 4. level ==========
    (fn ()
    ; Top row
    (entity-new-wall          0 -5)
    (entity-new-stop-counter  2 -5 1)

    ; 2. row
    (entity-new-stop-counter -4 -4 1)
    (entity-new-stop-counter  4 -4 1)

    ; 3. row
    (entity-new-wall         -1 -3)
    (entity-new-wall          1 -3)

    ; 4. row
    (entity-new-stop-counter -5 -2 1)
    (entity-new-key          -2 -2)
    (entity-new-wall         -1 -2)
    (entity-new-wall          1 -2)
    (entity-new-key           2 -2)

    ; 5. row
    (for i from -3 to -1 (entity-new-wall i -1))
    (for i from  1 to  3 (entity-new-wall i -1))

    ; 6. row
    (entity-new-wall         -5 0)
    (entity-new-player        0 0)
    (entity-new-wall          5 0)

    ; 7. row
    (for i from -3 to -1 (entity-new-wall i 1))
    (for i from  1 to  3 (entity-new-wall i 1))

    ; 8. row
    (entity-new-stop-counter  5  2 1)
    (entity-new-key          -2  2)
    (entity-new-wall         -1  2)
    (entity-new-wall          1  2)
    (entity-new-key           2  2)

    ; 9. row
    (entity-new-wall         -1  3)
    (entity-new-wall          1  3)

    ; 10. row
    (entity-new-stop-counter -4  4 1)
    (entity-new-stop-counter  4  4 1)

    ; Last row
    (entity-new-exit         -4  5)
    (entity-new-stop-counter -2  5 1)
    (entity-new-wall          0  5))


    ; ========== 5. level ==========
    (fn ()
    ; Top row
    (entity-new-slope-es   0 -4)
    (entity-new-slope-sw   5 -4)

    ; 2. row
    ;-

    ; 3. row
    (entity-new-bomb      -4 -2 7)

    ; 4. row
    (entity-new-exit         -6 -1)
    (entity-new-turnstile-ns -3 -1)
    (entity-new-player        0 -1)
    (entity-new-pass-counter  5 -1 2)

    ; 5. row
    (entity-new-wall          3 0)

    ; 6. row
    (entity-new-wall         -2 1)

    ; 7. row
    (entity-new-wall         -5 2)
    (entity-new-wall          2 2)

    ; 8. row
    (entity-new-key          -3 3)

    ; 9. row
    (entity-new-wall         -3 4)
    (entity-new-slope-en      0 4)
    (entity-new-slope-nw      5 4)

    ; 10. row
    (entity-new-wall         -1 5))



    ; ========== 6. level ==========
    (fn ()
    ; Top row
    (entity-new-wall      -7  -7)

    ; 2. row
    (entity-new-wall      -2  -6)
    (entity-new-key       -1  -6)
    (entity-new-slope-sw   2  -6)

    ; 3. row
    (entity-new-wall       5  -5)

    ; 4. row
    (entity-new-wall      -5  -4)
    (entity-new-wall      -4  -4)
    (entity-new-wall       0  -4)
    (entity-new-wall       1  -4)

    ; 5. row
    (entity-new-wall          -6  -3)
    (entity-new-key           -4  -3)
    (entity-new-turnstile-we  -3  -3)
    (entity-new-turnstile-ns  -1  -3)
    (entity-new-key            0  -3)
    (entity-new-wall           2  -3)

    ; 6. row
    (entity-new-slope-es      -8  -2)
    (entity-new-turnstile-ew  -6  -2)
    (entity-new-wall          -2  -2)
    (entity-new-turnstile-we   2  -2)
    (entity-new-turnstile-we   4  -2)
    (entity-new-bomb           6  -2 10)

    ; 7. row
    (entity-new-wall          -6  -1)
    (entity-new-wall           2  -1)
    (entity-new-exit           8  -1)

    ; 8. row
    (entity-new-wall          -6   0)
    (entity-new-wall           2   0)

    ; 9. row
    (entity-new-wall          -8   1)
    (entity-new-wall          -5   1)
    (entity-new-wall           1   1)
    (entity-new-slope-nw       6   1)

    ; 10. row
    (entity-new-wall          -4   2)
    (entity-new-wall          -0   2)

    ; 11. row
    (entity-new-wall          -7   3)
    (entity-new-wall          -3   3)
    (entity-new-wall          -1   3)
    (entity-new-wall           3   3)

    ; 12. row
    (entity-new-turnstile-sn  -2   4)

    ; 13. row
    (entity-new-wall           1   5)

    ; 14. row
    (entity-new-wall          -5   6)

    ; Bottom row
    (entity-new-player        -8   7)
    (entity-new-wall          -1   7))



    ; ========== 7. level ==========
    (fn ()
    ; top row
    (for i from -8 to 0 (entity-new-wall i -6))

    ; next row
    (entity-new-wall   -8 -5)
    (entity-new-player -7 -5)
    (for i from 0 to 7 (entity-new-wall  i -5))

    ; Third row from top
    (entity-new-wall -8 -4)
    (entity-new-wall  7 -4)

    ; Fourth row from top
    (entity-new-wall -8 -3)
    (entity-new-pullable-ensw 6 -3)
    (entity-new-wall  7 -3)

    ; Fifth
    (entity-new-wall -8 -2)
    (entity-new-wall -5 -2)
    (entity-new-wall -4 -2)
    (for i from -3 to -1 (entity-new-pullable-ensw i -2))
    (entity-new-wall 0 -2)
    (entity-new-wall 1 -2)
    (entity-new-pullable-ensw 2 -2)
    (entity-new-wall 3 -2)
    (entity-new-wall 4 -2)
    (entity-new-wall 7 -2)

    ; Sixth
    (entity-new-wall -8 -1)
    (entity-new-wall -5 -1)
    (entity-new-wall -4 -1)
    (entity-new-pullable-ensw -3 -1)
    (entity-new-pullable-ensw -2 -1)
    (for i from -1 to 1 (entity-new-wall i -1))
    (entity-new-pullable-ensw 2 -1)
    (entity-new-wall 3 -1)
    (entity-new-wall 4 -1)
    (entity-new-wall 7 -1)

    ; Seventh
    (entity-new-wall -8 0)
    (entity-new-wall -5 0)
    (entity-new-wall -4 0)
    (for i from -3 to 2 (entity-new-pullable-ensw i 0))
    (entity-new-wall 3 0)
    (entity-new-wall 4 0)
    (entity-new-wall 7 0)

    ; Eight
    (entity-new-wall -8 1)
    (entity-new-wall -5 1)
    (entity-new-wall -4 1)
    (entity-new-pullable-ensw -3 1)
    (entity-new-pullable-ensw -2 1)

    (entity-new-exit  0 1)

    (entity-new-pullable-ensw 2 1)
    (entity-new-wall 3 1)
    (entity-new-wall 4 1)
    (entity-new-wall 7 1)

    ; Ninth
    (entity-new-wall -8 2)
    (entity-new-wall -5 2)
    (entity-new-wall -4 2)
    (entity-new-pullable-ensw -3 2)
    (entity-new-pullable-ensw -2 2)
    (for i from -1 to 1 (entity-new-wall i 2))
    (entity-new-pullable-ensw 2 2)
    (entity-new-wall 3 2)
    (entity-new-wall 4 2)
    (entity-new-wall 7 2)

    ; Tenth
    (entity-new-wall -8 3)
    (entity-new-pullable-ensw  6 3)
    (entity-new-wall  7 3)

    ; Eleventh
    (entity-new-wall -8 4)
    (entity-new-wall -7 4)
    (entity-new-wall  7 4)

    ; Bottom row
    (for i from -7 to 7 (entity-new-wall i 5)))



    ; ========== 8. level ==========
    (fn ()
    ; Top row
    (for i from -7 to -3 (entity-new-wall i -4))
    (for i from -1 to  1 (entity-new-wall i -4))

    ; 2. row
    (entity-new-wall -7 -3)
    (entity-new-wall  0 -3)

    ; 3. row
    (entity-new-wall         -7 -2  )
    (entity-new-wall          0 -2  )
    (entity-new-pass-counter  1 -2 2)

    ; 4. row
    (entity-new-exit         -8 -1  )
    (entity-new-pass-counter -3 -1 4)
    (entity-new-turnstile-ew  0 -1  )
    (entity-new-pass-counter  4 -1 2)
    (entity-new-slope-sw      6 -1  )

    ; 5. row
    (entity-new-wall         -6 0)
    (entity-new-player       -5 0)
    (entity-new-wall          0 0)
    (entity-new-wall          8 0)

    ; 6. row
    (entity-new-wall         -6 1  )
    (entity-new-turnstile-we  0 1  )
    (entity-new-stop-counter  3 1 4)
    (entity-new-slope-nw      6 1  )

    ; 7. row
    (entity-new-wall         -6 2  )
    (entity-new-pass-counter -4 2 1)

    ; 8. row
    (entity-new-wall         -6 3  )
    (entity-new-stop-counter -2 3 1)
    (entity-new-wall          0 3  )
    (entity-new-key           7 3  )

    ; Last row
    (entity-new-wall         -6 4 )
    (entity-new-wall         -5 4 )
    (entity-new-wall          0 4 )
    (entity-new-stop-counter  1 4 1)
    (entity-new-wall          7 4 ))



    ; ========== 9. level ==========
    (fn ()
    ; Top row
    (entity-new-exit          0  -9)

    (for i from -7 to 7 (entity-new-pullable-ensw i  -7))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -6))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -5))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -4))

    (for i from -7 to -2 (entity-new-pullable-ensw i  -3))
    (for i from  2 to  7 (entity-new-pullable-ensw i  -3))

    (for i from -7 to -3 (entity-new-pullable-ensw i  -2))
    (for i from  3 to  7 (entity-new-pullable-ensw i  -2))

    (for i from -7 to -4 (entity-new-pullable-ensw i  -1))
    (for i from  4 to  7 (entity-new-pullable-ensw i  -1))

    (entity-new-exit -9 0)
    (for i from -7 to -4 (entity-new-pullable-ensw i   0))
    (entity-new-player 0 0)
    (for i from  4 to  7 (entity-new-pullable-ensw i   0))
    (entity-new-exit  9 0)

    (for i from -7 to -4 (entity-new-pullable-ensw i   1))
    (for i from  4 to  7 (entity-new-pullable-ensw i   1))

    (for i from -7 to -3 (entity-new-pullable-ensw i   2))
    (for i from  3 to  7 (entity-new-pullable-ensw i   2))

    (for i from -7 to -2 (entity-new-pullable-ensw i   3))
    (for i from  2 to  7 (entity-new-pullable-ensw i   3))

    (for i from -7 to  7 (entity-new-pullable-ensw i   4))

    (for i from -7 to  7 (entity-new-pullable-ensw i   5))

    (for i from -7 to  7 (entity-new-pullable-ensw i   6))

    (for i from -7 to  7 (entity-new-pullable-ensw i   7))

    (entity-new-exit 0 9))



    ; ========== 10. level ==========
    (fn ()
    ; Top row
    (entity-new-wall 1 -8)

    ; 2. row
    (entity-new-wall -3 -7)
    (entity-new-key  -1 -7)

    ; 5. row
    (entity-new-wall -6 -4)

    ; 6. row
    (entity-new-wall -7 -3)
    (entity-new-wall  2 -3)
    (entity-new-wall  6 -3)

    ; 7. row
    (entity-new-wall -5 -2)

    ; 8.row
    (entity-new-wall -7 -1)
    (entity-new-wall -4 -1)

    ; 9. row
    (entity-new-key         -7 0)
    (entity-new-wall        -6 0)
    (entity-new-wall        -3 0)
    (entity-new-pass-counter 4 0 1)
    (entity-new-wall         5 0)
    (entity-new-exit         8 0)

    ; 10. row
    (entity-new-wall        -8 1)
    (entity-new-wall        -5 1)
    (entity-new-wall        -2 1)
    (entity-new-pass-counter 6 1 3)

    ; 11. row
    (entity-new-wall        -7 2)
    (entity-new-wall        -4 2)
    (entity-new-wall        -1 2)
    (entity-new-wall         1 2)
    (entity-new-stop-counter 7 2 1)

    ; 12. row
    (entity-new-wall        -6 3)
    (entity-new-wall        -3 3)
    (entity-new-wall         0 3)
    (entity-new-pass-counter 3 3 3)
    (entity-new-wall         5 3)
    (entity-new-wall         6 3)

    ; 13. row
    (entity-new-wall        -5 4)
    (entity-new-wall        -2 4)
    (entity-new-key         -1 4)

    ; 14. row
    (entity-new-wall        -4 5)
    (entity-new-wall        -1 5)
    (entity-new-wall         0 5)

    ; 15. row
    (entity-new-wall        -3 6)
    (entity-new-wall         4 6)

    ; 16. row
    (entity-new-wall        -2 7)
    (entity-new-wall         0 7)
    (entity-new-wall         2 7)

    ; 17. row
    (entity-new-wall         0 8)
    (entity-new-player       7 8))



    ; ========== 11. level ==========
    (fn ()
    ; Top to fifth rows
    (for y from -8 to -4
         (for x from -8 to 8 (entity-new-pullable-ensw x y)))

    ; 6. row
    (for x from -8 to -2 (entity-new-pullable-ensw x -3))
    (for x from  2 to  8 (entity-new-pullable-ensw x -3))

    ; 7. row
    (for x from -8 to -3 (entity-new-pullable-ensw x -2))
    (for x from  3 to  8 (entity-new-pullable-ensw x -2))

    ; 8. row
    (entity-new-exit -10 -1)
    (for x from -8 to -4 (entity-new-pullable-ensw x -1))
    (for x from  4 to  8 (entity-new-pullable-ensw x -1))

    ; 9. row
    (for x from -8 to -4 (entity-new-pullable-ensw x  0))
    (entity-new-player 0  0)
    (for x from  4 to  8 (entity-new-pullable-ensw x  0))

    ; 10. row
    (for x from -8 to -4 (entity-new-pullable-ensw x  1))
    (for x from  4 to  8 (entity-new-pullable-ensw x  1))

    ; 11. row
    (for x from -8 to -3 (entity-new-pullable-ensw x  2))
    (for x from  3 to  8 (entity-new-pullable-ensw x  2))

    ; 12. row
    (for x from -8 to -2 (entity-new-pullable-ensw x  3))
    (for x from  2 to  8 (entity-new-pullable-ensw x  3))

    ; Five bottom rows
    (for y from 4 to 8
         (for x from -8 to 8 (entity-new-pullable-ensw x y))))



    ; ========== 12. level ==========
    (fn ()
    ; Top row
    (entity-new-wall     -7  -6)
    (entity-new-wall     -6  -6)
    (entity-new-slope-es  0  -6)
    (entity-new-slope-sw  5  -6)

    ; 2. row
    (entity-new-key      -7  -5)
    (entity-new-key      -6  -5)

    ; 3. row
    (entity-new-wall         -5  -4)
    (entity-new-pass-counter -3  -4  1)
    (entity-new-key           0  -4)
    (entity-new-pullable-w    1  -4)
    (for x from 2 to 4 (entity-new-wall x -4))

    ; 4. row
    (entity-new-turnstile-we 0 -3)
    (entity-new-turnstile-we 4 -3)
    (entity-new-key          6 -3)
    (entity-new-slope-sw     7 -3)

    ; 5. row
    (entity-new-pass-counter -6  -2  2)
    (entity-new-wall         -1  -2)
    (entity-new-wall          0  -2)
    (entity-new-turnstile-ns  1  -2)
    (entity-new-wall          4  -2)

    ; 6. row
    (entity-new-key  -5 -1)
    (entity-new-wall -4 -1)
    (entity-new-wall  0 -1)
    (entity-new-wall  4 -1)

    ; 7. row
    (entity-new-pullable-nw 4 0)
    (entity-new-slope-nw    5 0)

    ; 8. row
    (entity-new-pullable-n  1 1)
    (for x from 2 to 4 (entity-new-wall x 1))

    ; 9. row
    (entity-new-slope-en -7 2)
    (entity-new-key      -1 2)
    (entity-new-slope-sw  6 2)

    ; 10. row
    (entity-new-pass-counter -6 3 4)
    (entity-new-turnstile-ns  7 3)

    ; 11. row
    (entity-new-wall -7 4)

    ; 12. row
    (entity-new-wall    -6 5)
    (entity-new-exit    -5 5)
    (entity-new-player   0 5)
    (entity-new-slope-nw 6 5)
    (entity-new-wall     7 5))



    ; ========== 13. level ==========
    (fn ()
    ; Top row
    (entity-new-slope-es -5 -6)
    (entity-new-bomb     -1 -6 7)

    ; 3. row
    (entity-new-wall      3 -4)
    (entity-new-wall      4 -4)

    ; 4. row
    (entity-new-wall         -3 -3)
    (entity-new-pass-counter  0 -3 1)
    (entity-new-player        3 -3)
    (entity-new-slope-sw      7 -3)

    ; 6. row
    (entity-new-turnstile-ns  7 -1)

    ; 7. row
    (entity-new-bomb -5 0 5)
    (entity-new-pass-counter -2 0 2)
    (entity-new-slope-nw 3 0)

    ; 8. row
    (entity-new-wall -7 1)
    (entity-new-key  -6 1)
    (entity-new-wall -4 1)
    (entity-new-wall  6 1)
    (entity-new-exit  7 1)

    ; 10. row
    (entity-new-pass-counter -1 3 3)

    ; 11. row
    (entity-new-slope-en -5 4)

    ; 12. row
    (entity-new-wall -1 5))



    ; ========== 14. level ==========
    (fn ()
    ; Top row
    (for x from -9 to 9 (entity-new-wall x -4))

    ; 2. row
    (entity-new-wall         -9 -3)
    (entity-new-stop-counter -3 -3 1)
    (entity-new-stop-counter  1 -3 1)
    (entity-new-stop-counter  5 -3 1)
    (entity-new-key           8 -3)
    (entity-new-wall          9 -3)

    ; 3. row
    (entity-new-wall                     -9 -2)
    (for x from -7 to -6 (entity-new-wall x -2))
    (for x from -3 to -2 (entity-new-wall x -2))
    (for x from  1 to  2 (entity-new-wall x -2))
    (for x from  5 to  7 (entity-new-wall x -2))
    (entity-new-turnstile-ns              8 -2)
    (entity-new-wall                      9 -2)

    ; 4. row
    (entity-new-wall         -9 -1)
    (entity-new-pullable-ns  -4 -1)
    (entity-new-pullable-ns   0 -1)
    (entity-new-pullable-ns   4 -1)
    (entity-new-wall          9 -1)

    ; 5. row
    (for x from -9 to -5 (entity-new-wall x 0))
    (for x from -3 to -1 (entity-new-wall x 0))
    (for x from  1 to  3 (entity-new-wall x 0))
    (for x from  5 to  7 (entity-new-wall x 0))
    (entity-new-wall                      9 0)

    ; 6. row
    (entity-new-exit         -9 1)
    (entity-new-player       -7 1)
    (entity-new-slope-sw     -3 1)
    (entity-new-slope-sw      1 1)
    (entity-new-slope-sw      5 1)
    (entity-new-wall          9 1)

    ; 7. row
    (entity-new-wall         -9 2)
    (entity-new-wall         -5 2)
    (entity-new-wall         -1 2)
    (entity-new-wall          3 2)
    (entity-new-wall          9 2)

    ; Bottom row
    (for x from -9 to -5 (entity-new-wall  x 3))
    (entity-new-pullable-n                -4 3)
    (for x from -3 to -1 (entity-new-wall  x 3))
    (entity-new-pullable-n                 0 3)
    (for x from  1 to  3 (entity-new-wall  x 3))
    (entity-new-pullable-n                 4 3)
    (for x from  5 to  9 (entity-new-wall  x 3)))



    ; ========== 15. level ==========
    (fn ()
    ; Top row
    (for i from -6 to 6 (entity-new-wall i -6))

    ; 2. row
    (entity-new-wall -6 -5)
    (for i from -5 to 5 (entity-new-stopper i -5))
    (entity-new-wall  6 -5)

    ; 3 - 5. row
    (for i from -4 to -2
        (entity-new-wall    -6 i)
        (entity-new-stopper -5 i)
        (entity-new-stopper  5 i)
        (entity-new-wall     6 i))

    ; 6. row
    (entity-new-wall    -6 -1)
    (entity-new-stopper -5 -1)
    (for i from -3 to 3 (entity-new-pullable-ensw i -1))
    (entity-new-stopper  5 -1)
    (entity-new-wall     6 -1)

    ; 7. row
    (entity-new-wall    -6 0)
    (entity-new-stopper -5 0)
    (for i from -3 to 3 step 2 (entity-new-pullable-ensw i 0))
    (for i from -2 to 2 step 2 (entity-new-toggle        i 0))
    (entity-new-stopper  5 0)
    (entity-new-wall     6 0)

    ; 8. row
    (entity-new-wall    -6 1)
    (entity-new-stopper -5 1)
    (for i from -3 to 3 (entity-new-pullable-ensw i 1))
    (entity-new-stopper  5 1)
    (entity-new-wall     6 1)

    ; 9 - 11. row
    (for i from 2 to 4
        (entity-new-wall    -6 i)
        (entity-new-stopper -5 i)
        (entity-new-stopper  5 i)
        (entity-new-wall     6 i))

    (entity-new-player       4 4)

    ; 12. row
    (entity-new-wall -6 5)
    (for i from -5 to 5 (entity-new-stopper i 5))
    (entity-new-wall  6 5)

    ; Bottom row
    (for i from -6 to -1 (entity-new-wall i 6))
    (entity-new-exit 0 6)
    (for i from  1 to  6 (entity-new-wall i 6)))



    ; ========== 16. level ==========
    (fn ()
    ; Top row
    (for x from -8 to 8 (entity-new-wall x -5))

    ; 2. row
    (entity-new-wall         -8 -4)
    (entity-new-wall         -4 -4)
    (entity-new-wall          1 -4)
    (entity-new-turnstile-we  4 -4)
    (entity-new-bomb          8 -4 5)

    ; 3. row
    (entity-new-bomb         -8 -3 5)
    (entity-new-player       -7 -3)
    (entity-new-turnstile-ew -4 -3)
    (entity-new-wall          1 -3)
    (entity-new-pass-counter  2 -3 2)
    (entity-new-turnstile-ew  4 -3)
    (entity-new-wall          8 -3)

    ; 4. row
    (entity-new-wall         -8 -2)
    (entity-new-turnstile-we -4 -2)
    (entity-new-pass-counter -3 -2 2)
    (entity-new-pass-counter -1 -2 2)
    (entity-new-turnstile-ew  1 -2)
    (entity-new-wall          4 -2)
    (entity-new-pass-counter  5 -2 3)
    (entity-new-key           6 -2)
    (entity-new-bomb          8 -2 5)

    ; 5. row
    (entity-new-wall                      -8 -1)
    (for x from -4 to -2 (entity-new-wall  x -1))
    (entity-new-turnstile-we               1 -1)
    (entity-new-bomb                       4 -1 5)
    (entity-new-pass-counter               5 -1 2)
    (entity-new-wall                       8 -1)

    ; 6. row
    (entity-new-wall                      -8 0)
    (entity-new-wall                      -4 0)
    (entity-new-wall                       1 0)
    (entity-new-wall                       4 0)
    (entity-new-wall                       8 0)

    ; 7. row
    (entity-new-wall                      -8 1)
    (entity-new-pass-counter              -5 1 2)
    (entity-new-wall                      -4 1)
    (entity-new-wall                       1 1)
    (for x from 4 to 8 (entity-new-wall    x 1))

    ; 8. row
    (for x from -8 to -7 (entity-new-wall  x 2))
    (entity-new-turnstile-ns              -6 2)
    (for x from -5 to -4 (entity-new-wall  x 2))
    (entity-new-pass-counter              -3 2 1)
    (entity-new-wall                      -2 2)
    (for x from 1 to 2 (entity-new-wall    x 2))
    (entity-new-turnstile-ns               3 2)
    (entity-new-wall                       4 2)
    (entity-new-wall                       8 2)

    ; 9. row
    (entity-new-exit                      -8 3)
    (entity-new-wall                      -2 3)
    (entity-new-wall                       1 3)
    (entity-new-wall                       8 3)

    ; Bottom row
    (entity-new-slope-en                  -6 4)
    (entity-new-bomb                      -2 4 20)
    (entity-new-slope-sw                  -1 4)
    (for x from 0 to 8 (entity-new-wall    x 4)))



    ; ========== 17. level ==========
    (fn ()
    ; Top row
    (for x from -5 to 5 (entity-new-wall x -9))

    ; 2. row
    (entity-new-wall -5 -8)
    (entity-new-wall  5 -8)

    ; 3. row
    (entity-new-wall -5 -7)
    (entity-new-wall  5 -7)

    ; 4. row
    (for x from -5 to 1 (entity-new-wall x -6))
    (for x from  4 to 5 (entity-new-wall x -6))

    ; 5. row
    (entity-new-wall                              -5 -5)
    (entity-new-exit                              -4 -5)
    (for x from -3 to 0 (entity-new-pullable-ensw  x -5))
    (entity-new-wall                               1 -5)
    (entity-new-wall                               5 -5)

    ; 6 - 10. rows
    (for y from -4 to 0
        (entity-new-wall                              -5 y)
        (for x from -4 to 0 (entity-new-pullable-ensw  x y))
        (entity-new-wall                               1 y)
        (entity-new-wall                               5 y))

    ; 11. row
    (entity-new-wall                              -5 1)
    (for x from -4 to 1 (entity-new-pullable-ensw  x 1))
    (entity-new-wall                               5 1)

    ; 12. row
    (entity-new-wall -5 2)
    (entity-new-wall  5 2)

    ; 13. row
    (entity-new-wall -5 3)
    (for x from 4 to 5 (entity-new-wall x 3))

    ; 14. row
    (entity-new-wall -5 4)
    (entity-new-wall  5 4)

    ; 15. row
    (entity-new-wall   -5 5)
    (entity-new-player  1 5)
    (entity-new-wall    5 5)

    ; 16. row
    (entity-new-wall                     -5 6)
    (for x from -3 to 2 (entity-new-wall  x 6))
    (entity-new-wall                      5 6)

    ; 17. row
    (entity-new-wall -5 7)
    (entity-new-wall  5 7)

    ; 18. row
    (for x from -5 to 5 (entity-new-wall x 8)))



    ; ========== 18. level ==========
    (fn ()
    ; Top row
    (for i from -6 to 6 (entity-new-stopper i  -6))

    ; 2. row
    (entity-new-stopper -6 -5)
    (entity-new-stopper  6 -5)

    ; 3. row
    (entity-new-stopper -6 -4)
    (for i from -4 to -2 (entity-new-pullable-ensw i -4))
    (for i from  2 to  4 (entity-new-pullable-ensw i -4))
    (entity-new-stopper  6 -4)

    ; 4. row
    (entity-new-stopper -6 -3)
    (entity-new-pullable-ensw -4 -3)
    (entity-new-toggle        -3 -3)
    (entity-new-pullable-ensw -2 -3)
    (entity-new-pullable-ensw -1 -3)
    (entity-new-pullable-ensw  1 -3)
    (entity-new-pullable-ensw  2 -3)
    (entity-new-toggle         3 -3)
    (entity-new-pullable-ensw  4 -3)
    (entity-new-stopper  6 -3)

    ; 5. row
    (entity-new-stopper -6 -2)
    (for i from  -4 to 4 (entity-new-pullable-ensw i -2))
    (entity-new-stopper  6 -2)

    ; 6. row
    (entity-new-stopper -6 -1)
    (for i from  -3 to 3 (entity-new-pullable-ensw i -1))
    (entity-new-stopper  6 -1)

    ; 7. row
    (entity-new-stopper -6 0)
    (entity-new-pullable-ensw -2 0)
    (entity-new-pullable-ensw -1 0)
    (entity-new-exit           0 0)
    (entity-new-pullable-ensw  1 0)
    (entity-new-pullable-ensw  2 0)
    (entity-new-stopper  6 0)

    ; 8. row
    (entity-new-stopper -6 1)
    (for i from  -3 to 3 (entity-new-pullable-ensw i 1))
    (entity-new-stopper  6 1)

    ; 9. row
    (entity-new-stopper -6 2)
    (for i from  -4 to 4 (entity-new-pullable-ensw i 2))
    (entity-new-stopper  6 2)

    ; 10. row
    (entity-new-stopper -6       3)
    (entity-new-pullable-ensw -4 3)
    (entity-new-toggle        -3 3)
    (entity-new-pullable-ensw -2 3)
    (entity-new-pullable-ensw -1 3)
    (entity-new-pullable-ensw  1 3)
    (entity-new-pullable-ensw  2 3)
    (entity-new-toggle         3 3)
    (entity-new-pullable-ensw  4 3)
    (entity-new-stopper        6 3)

    ; 11. row
    (entity-new-stopper -6 4)
    (for i from -4 to -2 (entity-new-pullable-ensw i 4))
    (for i from  2 to  4 (entity-new-pullable-ensw i 4))
    (entity-new-stopper  6 4)

    ; 12. ro
    (entity-new-stopper -6 5)
    (entity-new-stopper  6 5)

    ; 13. row
    (for i from -6 to 6 (entity-new-stopper i  6))

    ; Bottom row
    (entity-new-player      0   8))



) [levels])


(define number-of-levels as (fn () (len levels)) [number of levels] '() howto-ok)

(define level-load as (fn (levelNumber)
    (define f as (ln@ levels (- levelNumber 1)) [f])
    ((eval f))
    (= level-current-number levelNumber))
  [load level from vector index] '(levelNumber [1..n]) howto-no)

(define level-restart as (fn ()
    (level-reset)

    (define lnum as level-current-number [level number before change])

    (level-load lnum)

    (shake))
  [restart level] '() howto-no)

(define level-prev as (fn ()
    (level-reset)

    (define lnum as (- level-current-number 1) [level number])

    (if (< lnum 1) (= lnum (number-of-levels)))

    (level-load lnum))
  [previous level] '() howto-no)

(define level-next as (fn ()
    (level-reset)

    (define lnum as (+ level-current-number 1) [level number])

    (if (> lnum (number-of-levels)) (= lnum 1))

    (level-load lnum))
  [next level] '() howto-no)

(define current-state as [intro] [current-state])
(define pending-input as '()     [pending input that is not yet handled])

(define pop-input as (fn ()

    (define result as [] [result])

    (if (!= 0 (len pending-input))
        (do
            (= result (cp@ pending-input 0))
            (pop-front pending-input)))

    result)
  [pop input] '() howto-no)

(define printlevel as false [printlevel])

(define bomb-update as (fn (slot dt)
    (if (not (find slot 'bomb-started)) (return nil))
    (+= (find slot 'bomb-uptime) dt)

    (if (>= (find slot 'bomb-uptime) (find slot 'bomb-original-count)) (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y)))

    (define tmpSecs as (- (find slot 'bomb-original-count) (to-integer (find slot 'bomb-uptime))) [tmp secs])

    (define curSecs as (find slot 'count) [curret secs])
    (if (== curSecs 0) (do (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y) (return true))))
    (if (== tmpSecs 0) (do (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y) (return true))))

    (if (< tmpSecs curSecs) (do
                                (= slot 'count tmpSecs)
                                (animation-entity-remove (find slot 'name))
                                (animation-entity-new
                                    (find slot 'name)
                                    (string-format [bomb-{}] tmpSecs)
                                    '((* 16 (find slot 'x)) (* 16 (find slot 'y)) 0)))))
  [update a bomb] '(slot [slot for the bomb] dt [delta time]) howto-no)

(define stopper-update as (fn (slot dt)
    (if (!= player-x (find slot 'x)) (return nil))
    (if (!= player-y (find slot 'y)) (return nil))
    (set-player-dir nil))
  [update a stopper] '(slot [slot for the stopper] dt [delta time]) howto-no)

(define pullable-anytype-update as (fn (slot dt)
    (define px as (find slot 'x) [px])
    (define py as (find slot 'y) [py])

    (define currentSide as (coords-to-side px py player-x player-y) [current side])

    (= currentSide (reverse-side currentSide))

    (if (!= currentSide (find slot 'player-was-on-side))
        (do (-= level-updatable-indices (find slot 'name)) (return nil)))

    (select
        (== currentSide [u]) (move-pullable-up    px py)
        (== currentSide [d]) (move-pullable-down  px py)
        (== currentSide [l]) (move-pullable-left  px py)
        (== currentSide [r]) (move-pullable-right px py)))
  [update a any pullable type] '(slot [slot for the entity] dt [delta time]) howto-no)


(define state-update-game as (fn (dt input)

    (select
        (== input [restart])   (do (= input []) (level-restart))
        (== input [prevLevel]) (do (= input []) (level-prev))
        (== input [nextLevel]) (do (= input []) (level-next))
        (== input [action 1])  (do (= input []) (= printlevel (not printlevel))))

    (if (!= input []) (+= pending-input input))

    (if (== nil player-x)     (return nil))
    (if (== nil player-y)     (return nil))
    (if (== nil (get-player)) (return nil))

    (if (== (find (get-player) 'dir) nil)
        (do
            (= input (pop-input))
            (select
                (== input [up])       (= (get-player) 'dir [u])
                (== input [down])     (= (get-player) 'dir [d])
                (== input [left])     (= (get-player) 'dir [l])
                (== input [right])    (= (get-player) 'dir [r]))))

    (define player-dir as (find (get-player) 'dir) [player-dir])

    (select
        (== player-dir [u]) (move-player-to player-x       (- player-y 1))
        (== player-dir [d]) (move-player-to player-x       (+ player-y 1))
        (== player-dir [l]) (move-player-to (- player-x 1) player-y)
        (== player-dir [r]) (move-player-to (+ player-x 1) player-y))

    (if pass-or-fail-level-pending (do (pass-or-fail-level) (return true)))

    (define tmpPassCounters as nil [prevent problems of modifying during iteration])
    (= tmpPassCounters pass-counters)
    (for i in tmpPassCounters
        (pass-counter-update (ln@ i 1) dt))

    (define tmpLUI as nil [prevent problems of modifying during iteration])
    (= tmpLUI level-updatable-indices)
    (for i in tmpLUI
        (define zeroth as (ln@ i 0) [zeroth])
        (select
            (starts-with? zeroth [bomb])          (bomb-update             (ln@ i 1) dt)
            (starts-with? zeroth [stopper])       (stopper-update          (ln@ i 1) dt)
            (starts-with? zeroth [pullable-])     (pullable-anytype-update (ln@ i 1) dt)))

    true)
  [state-update]
  '(dt [delta time] input [string telling the input, if any: u, d, l, r]) howto-no)


(define state-update-intro as (fn (dt input)

    (if (== input [right]) (do (= current-state [intro-closing]) (tween-level-out)))
    true)
  [state-update]
  '(dt [delta time] input [string telling the input, if any: u, d, l, r]) howto-no)


(define state-update-tween-out as (fn (dt input)
    true)
  [state-update]
  '(dt [delta time] input [string telling the input, if any: u, d, l, r]) howto-no)

(define state-update as (fn (dt input)

    (if (> level-restart-pending 0)
      (do
        (-- level-restart-pending)
        (if (== level-restart-pending 0)
          (do
            (= level-restart-pending -1)
            (level-restart)
            (return true))
          (return true))))

    (select
        (== [intro]    current-state) (state-update-intro     dt input)
        (== [game]     current-state) (state-update-game      dt input)
        (== [tweenOut] current-state) (state-update-tween-out dt input))

    (if printlevel (level-print))

    true)
  [state-update]
  '(dt [delta time] input [string telling the input, if any: u, d, l, r]) howto-no)


(define state-on-tween-out-done as (fn ()
    (if (== [intro-closing] current-state)
      (do
        (animation-entity-remove [help])
        (= current-state [game])
        (level-load 1))
      (level-next))
    )
  [...] '() howto-no)

(define state-on-tween-in-done as (fn ()
    (= current-state [game]))
  [...] '() howto-no)

; Game starts here
(animation-custom-new [help] [help] '(-240 -209 0))


;;; Here are some helper functions for debugging purposes.
;;; Can be removed later

(define level-print-slot as (fn (x y)
    (define name as (find (level-get-slot x y) 'name) [name])
    (if (== [] name)                         (do (print [  ]) (return nil)))
    (if (starts-with? name [exit])           (do (print [EX]) (return nil)))
    (if (starts-with? name [player])         (do (print [:)]) (return nil)))
    (if (starts-with? name [wall])           (do (print [XX]) (return nil)))
    (if (starts-with? name [pullable])       (do (print [PP]) (return nil)))
    (if (starts-with? name [stop-counter])   (do (print [$$]) (return nil)))
    (if (starts-with? name [key])            (do (print [|bar||bar|]) (return nil)))
    (if (starts-with? name [bomb])           (do (print [!!]) (return nil)))
    (if (starts-with? name [slope-en])       (do (print [^_]) (return nil)))
    (if (starts-with? name [slope-es])       (do (print [|bar|']) (return nil)))
    (if (starts-with? name [slope-sw])       (do (print ['|bar|]) (return nil)))
    (if (starts-with? name [slope-nw])       (do (print [_|bar|]) (return nil)))
    (if (starts-with? name [toggle])         (do (print [TT])     (return nil)))
    (if (starts-with? name [turnstile])      (do (print [::])     (return nil)))
    (if (starts-with? name [stop-turnstile]) (do (print [;;])     (return nil)))
    (print name))
  [...] '(x [x] y [y]) howto-no)

(define level-print-row as (fn (y)
    (for x from (- level-hwidth) to (- level-hwidth 1) (level-print-slot x y))
    (println []))
  [...] '(y [y]) howto-no)

(define level-print as (fn ()
    (println [-------------------------------------------------])
    (for y from (- level-hwidth) to (- level-hwidth 1) (level-print-row y))
    (println [-------------------------------------------------]))
  [...] '() howto-no)


(define level-print-slot-id as (fn (x y)
    (define name as (find (level-get-slot x y) 'name) [name])
    (print name)

    (define spaces as (- 18 (len name)) [...])
    (for i from 0 to spaces (print [ ])))
  [...] '(x [x] y [y]) howto-no)

(define level-print-row-id as (fn (y)
    (for x from (- level-hwidth) to (- level-hwidth 1) (level-print-slot-id x y))
    (println []))
  [...] '(y [y]) howto-no)

(define level-print-id as (fn ()
    (for y from (- level-hwidth) to (- level-hwidth 1) (level-print-row-id y)))
  [...] '() howto-no)


