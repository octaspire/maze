(define level [level] '())
(define pass-counters [pass counters of the level] (hash-map))
(define level-width  [level-width] 20)
(define level-hwidth [level half width] (to-integer (* level-width 0.5)))
(define level-current-number [current level number] nil)
(define level-number-of-keys  [How many keys current level had when it started] 0)
(define player-x   [current player x]   nil)
(define player-y   [current player y]   nil)
(define level-updatable-indices [entities in current level that must be updated] (hash-map))
(define pass-or-fail-level-pending [.] false)
(define active-exit-x [x-coordinate of activated exit] nil)
(define active-exit-y [y-coordinate of activated exit] nil)
(define level-restart-pending [Negative: not pending] -1)

(define get-player [.] '() (fn ()
    (level-get-slot player-x player-y)))

(define make-empty-slot [make empty slot] '() (fn ()
    (hash-map
         'name []
         'x    0
         'y    0
         'dir  nil
         'count 0
         'bomb-original-count 0
         'bomb-started false
         'bomb-uptime 0
         'number-of-keys 0
         'player-was-on-side  []
         'toggle-e false
         'toggle-n false
         'toggle-s false
         'toggle-w false
         'decreasePending false
         'removePending false)))

(define level-init [init level] '() (fn ()
    (for i from 0 to (* level-width level-width) (+= level (make-empty-slot)))))

(level-init)

(define level-reset [clear level] '() (fn ()
    (animation-entity-remove-all)
    (= pending-input '())
    (= level-updatable-indices (hash-map))
    (= level-number-of-keys 0)
    (= player-x nil)
    (= player-y nil)
    (= pass-or-fail-level-pending false)
    (= active-exit-x nil)
    (= active-exit-y nil)
    ; TODO why this doesn't work?
    ;(for i from 0 to (* level-width level-width) (= (nth level i) 'name []))
    (for i in level (= i 'name []))
    (= pass-counters (hash-map))
    ))

(define coordinates-to-index [...] '(x [x] y [y]) (fn (x y)
    (+ (+ x level-hwidth) (* (+ y level-hwidth) level-width))))

(define level-set-slot [level-set-slot] '(x [x] y [y] slot [slot]) (fn (x y slot)
    (= (nth (coordinates-to-index x y) level) slot)))

(define level-set-slot-to-empty [level-set-slot] '(x [x] y [y]) (fn (x y)
    (= (level-get-slot x y) 'name [])))

(define level-get-slot [level-get-slot] '(x [x] y [y]) (fn (x y)
    (nth (coordinates-to-index x y) level)))

(define level-is-slot-empty? [level-is-slot-empty?] '(x [x] y [y]) (fn (x y)
    (== [] (find (level-get-slot x y) 'name))))


(define level-move-slot [level-move-slot] '(fx [fx] fy [fy] tx [tx] ty [ty]) (fn (fx fy tx ty)
    (level-set-slot tx ty (level-get-slot fx fy))
    (level-set-slot-to-empty fx fy)
    (= (level-get-slot tx ty) 'x tx)
    (= (level-get-slot tx ty) 'y ty)
    ))

(define are-coordinates-out-of-level [check if coordinates are outside level area] '(x [x] y [y]) (fn (x y)
    (select
        (< x (- level-hwidth))  true
        (>= x level-hwidth)     true
        (< y (- level-hwidth))  true
        (>= y level-hwidth)     true
        default                 false)))

(define dir-to-side [dir-to-side] '(dir [dir]) (fn (dir)
    (select
        (== dir [u]) [d]
        (== dir [d]) [u]
        (== dir [l]) [r]
        (== dir [r]) [l]
        default      nil)))

(define coords-to-side [coords-to-side] '(ex [ex] ey [ey] px [px] py [py]) (fn (ex ey px py)
    (if (== ex px)
        (if (== ey py) (return nil) (if (> ey py) (return [d]) (return [u]))))

    (if (== ey py)
        (if (== ex px) (return nil) (if (> ex px) (return [r]) (return [l]))))

    nil))

(define bomb-remove [remove the named bomb at the given coordinates] '(name [name] x [x] y [y]) (fn (name x y)
    (level-set-slot-to-empty x y)
    (animation-entity-remove name)
    (-= level-updatable-indices name) 
    nil))

(define bomb-on-collision [should be called when bomb has collision with player] '(name [bomb's name] x [bomb's x] y [bomb's y]) (fn (name x y)
        (define slot [slot at x y, the bomb] (level-get-slot x y))
        (if (find slot 'bomb-started) (bomb-remove name x y) (= slot 'bomb-started true))))

(define toggle-open? [...] '(slot [slot]) (fn (slot)
    (select
        (== (find slot 'toggle-e) false) true
        (== (find slot 'toggle-n) false) true
        (== (find slot 'toggle-s) false) true
        (== (find slot 'toggle-w) false) true
        default                          false)))

(define toggle-set-correct-animation [...] '(name [name] x [x] y [y]) (fn (name x y)
        (define slot [slot at x y, the toggle] (level-get-slot x y))

        (define e [e] (find slot 'toggle-e))
        (define n [e] (find slot 'toggle-n))
        (define s [e] (find slot 'toggle-s))
        (define w [e] (find slot 'toggle-w))

        (select
            ; 1 none
            (and (not e) (not n) (not s) (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-none-idle] '((* 16 x) (* 16 y) 0)))

            ; 2 east
            (and e (not n) (not s) (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-e-idle] '((* 16 x) (* 16 y) 0)))

            ; 3 north
            (and (not e) n (not s) (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-n-idle] '((* 16 x) (* 16 y) 0)))

            ; 4 east and north
            (and e n (not s) (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-en-idle] '((* 16 x) (* 16 y) 0)))

            ; 5 south only
            (and (not e) (not n) s (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-s-idle] '((* 16 x) (* 16 y) 0)))

            ; 6 es
            (and e (not n) s (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-es-idle] '((* 16 x) (* 16 y) 0)))

            ; 7 ns
            (and (not e) n s (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-ns-idle] '((* 16 x) (* 16 y) 0)))

            ; 8 ens
            (and e n s (not w)) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-ens-idle] '((* 16 x) (* 16 y) 0)))

            ; 9 w
            (and (not e) (not n) (not s) w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-w-idle] '((* 16 x) (* 16 y) 0)))

            ; 10 ew
            (and e (not n) (not s) w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-ew-idle] '((* 16 x) (* 16 y) 0)))

            ; 11 nw
            (and (not e) n (not s) w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-nw-idle] '((* 16 x) (* 16 y) 0)))

            ; 12 enw
            (and e n (not s) w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-enw-idle] '((* 16 x) (* 16 y) 0)))

            ; 13 sw
            (and (not e) (not n) s w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-sw-idle] '((* 16 x) (* 16 y) 0)))

            ; 14 esw
            (and e (not n) s w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-esw-idle] '((* 16 x) (* 16 y) 0)))

            ; 15 nsw
            (and (not e) n s w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-nsw-idle] '((* 16 x) (* 16 y) 0)))

            ; 16 ensw
            (and e n s w) (do
                (animation-entity-remove name)
                (animation-entity-new name [toggle-ensw-idle] '((* 16 x) (* 16 y) 0))))))

(define toggle-on-collision [should be called when toggle has collision with player] '(name [toggle's name] x [toggle's x] y [toggle's y] pdir [player's dir]) (fn (name x y pdir)
        (define slot [slot at x y, the toggle] (level-get-slot x y))

        (select
            (== pdir [u]) (do (= slot 'toggle-s true) (toggle-set-correct-animation name x y))
            (== pdir [d]) (do (= slot 'toggle-n true) (toggle-set-correct-animation name x y))
            (== pdir [l]) (do (= slot 'toggle-e true) (toggle-set-correct-animation name x y))
            (== pdir [r]) (do (= slot 'toggle-w true) (toggle-set-correct-animation name x y)))))

(define stop-counter-remove [remove the named stop counter at the given coordinates] '(name [name] x [x] y [y]) (fn (name x y)
    (level-set-slot-to-empty x y)
    (animation-entity-remove name)))

(define get-player-num-keys [.] '() (fn ()
    (find (get-player) 'number-of-keys)))

(define set-player-dir [.] '(dir [dir]) (fn (dir)
    (= (get-player) 'dir dir)))

(define get-player-current-pullable-id [.] '() (fn ()
    (find (get-player) 'current-pullable-id)))

(define stop-counter-on-collision [should be called when stop counter has collision with player] '(name [counter's name] x [counter's x] y [counter's y]) (fn (name x y)
        (define slot [slot at x y, the counter] (level-get-slot x y))
        (define count [count before collision] (find slot 'count))
        (if (== count 1) (do (stop-counter-remove name x y) (return nil)))
        (define animationName [name of the animation] (string-format [stop-counter-{}] count))
        (animation-entity-remove name)
        (-= count 1)
        (define animationName [name of the animation] (string-format [stop-counter-{}] count))
        (animation-entity-new name animationName '((* 16 x) (* 16 y) 0))
        (= slot 'count count)))

(define key-on-collision [should be called when key has collision with player] '(name [key's name] x [key's x] y [key's y]) (fn (name x y)
        (level-set-slot-to-empty x y)
        (animation-entity-remove name)
        (= (get-player) 'number-of-keys (++ (find (get-player) 'number-of-keys)))))

(define turnstile-ew-on-collision [should be called when turnstile-ew has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] (+ x 1))
        (define fy [fy] y)
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] (- x 1))
        (define ty [ty] y)
        (move-player-to tx ty)
        (= (get-player) 'dir pdir)))

(define turnstile-we-on-collision [should be called when turnstile-we has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] (- x 1))
        (define fy [fy] y)
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] (+ x 1))
        (define ty [ty] y)
        (move-player-to tx ty)
        (= (get-player) 'dir pdir)))

(define turnstile-sn-on-collision [should be called when turnstile-sn has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] x)
        (define fy [fy] (+ y 1))
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] x)
        (define ty [ty] (- y 1))
        (move-player-to tx ty)
        (= (get-player) 'dir pdir)))

(define turnstile-ns-on-collision [should be called when turnstile-ns has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] x)
        (define fy [fy] (- y 1))
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] x)
        (define ty [ty] (+ y 1))
        (move-player-to tx ty)
        (= (get-player) 'dir pdir)))




(define stop-turnstile-ew-on-collision [should be called when stop-turnstile-ew has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] (+ x 1))
        (define fy [fy] y)
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] (- x 1))
        (define ty [ty] y)
        (move-player-to tx ty)))

(define stop-turnstile-we-on-collision [should be called when stop-turnstile-we has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] (- x 1))
        (define fy [fy] y)
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] (+ x 1))
        (define ty [ty] y)
        (move-player-to tx ty)))

(define stop-turnstile-sn-on-collision [should be called when stop-turnstile-sn has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] x)
        (define fy [fy] (+ y 1))
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] x)
        (define ty [ty] (- y 1))
        (move-player-to tx ty)))

(define stop-turnstile-ns-on-collision [should be called when stop-turnstile-ns has collision with player] '(name [turnstile's name] x [turnstile's x] y [turnstile's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx [fx] x)
        (define fy [fy] (- y 1))
        (if (!= fx player-x) (return nil))
        (if (!= fy player-y) (return nil))
        (define tx [tx] x)
        (define ty [ty] (+ y 1))
        (move-player-to tx ty)))






(define slope-en-on-collision [should be called when slope-en has collision with player] '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx1 [fx1] x)
        (define fy1 [fy1] (- y 1))
        (define fx2 [fx2] (+ x 1))
        (define fy2 [fy2] y)
        (define tx1 [tx1] fx2)
        (define ty1 [ty1] fy2)
        (define tx2 [tx2] fx1)
        (define ty2 [ty2] fy1)
        (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [r]) (return nil)))
        (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [u]) (return nil)))))

(define slope-es-on-collision [should be called when slope-es has collision with player] '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx1 [fx1] x)
        (define fy1 [fy1] (+ y 1))
        (define fx2 [fx2] (+ x 1))
        (define fy2 [fy2] y)
        (define tx1 [tx1] fx2)
        (define ty1 [ty1] fy2)
        (define tx2 [tx2] fx1)
        (define ty2 [ty2] fy1)
        (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [r]) (return nil)))
        (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [d]) (return nil)))))

(define slope-nw-on-collision [should be called when slope-nw has collision with player] '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx1 [fx1] x)
        (define fy1 [fy1] (- y 1))
        (define fx2 [fx2] (- x 1))
        (define fy2 [fy2] y)
        (define tx1 [tx1] fx2)
        (define ty1 [ty1] fy2)
        (define tx2 [tx2] fx1)
        (define ty2 [ty2] fy1)
        (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [l]) (return nil)))
        (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [u]) (return nil)))))

(define slope-sw-on-collision [should be called when slope-sw has collision with player] '(name [slope's name] x [slope's x] y [slope's y] pdir [player's dir]) (fn (name x y pdir)
        (define fx1 [fx1] x)
        (define fy1 [fy1] (+ y 1))
        (define fx2 [fx2] (- x 1))
        (define fy2 [fy2] y)
        (define tx1 [tx1] fx2)
        (define ty1 [ty1] fy2)
        (define tx2 [tx2] fx1)
        (define ty2 [ty2] fy1)
        (if (and (== fx1 player-x) (== fy1 player-y)) (do (move-player-to tx1 ty1) (= (get-player) 'dir [l]) (return nil)))
        (if (and (== fx2 player-x) (== fy2 player-y)) (do (move-player-to tx2 ty2) (= (get-player) 'dir [d]) (return nil)))))

(define exit-change-to-animation [Make exit to show the named animation] '(x [x of exit] y [y of exit] name [name of animation to show])
  (fn (x y name)
    (if (or (nil? x) (nil? y)) return)
    (animation-entity-remove (find (level-get-slot x y) 'name))
    (define id [id] (string-format [exit-{}-{}] x y))
    (animation-entity-new id name '((* 16 x) (* 16 y) 0))))

(define pass-or-fail-level [Move to next level or restart current] '() (fn ()
    (animation-entity-remove (find (level-get-slot player-x player-y) 'name))

    (if (< (find (get-player) 'number-of-keys) level-number-of-keys)
      (do
        (exit-change-to-animation active-exit-x active-exit-y [exit-fail])
        (= level-restart-pending 10)
        (return nil)))

    (for slot in level
         (if (starts-with? (find slot 'name) [toggle])
           (if (toggle-open? slot)
             (do
               (exit-change-to-animation active-exit-x active-exit-y [exit-fail])
               (= level-restart-pending 10)
               (return nil)))))

    ; Level is passed
    (exit-change-to-animation active-exit-x active-exit-y [exit-pass])
    (= current-state [tweenOut])
    (tween-level-out)))

(define on-collision [on-collision] '(tx [tx] ty [ty] dir [player's direction]) (fn (tx ty dir)
    (define slot [slot at tx ty, the thing collided with] (level-get-slot tx ty))
    (define name [name] (find slot 'name))

    (define side [on which side is player of the target] (dir-to-side dir))

    (select
        (starts-with? name [exit])              (do (= active-exit-x tx) (= active-exit-y ty) (= pass-or-fail-level-pending true))
        (starts-with? name [pullable])          (pullable-on-collision name slot side)
        (starts-with? name [stop-counter])      (stop-counter-on-collision name tx ty)
        (starts-with? name [bomb])              (bomb-on-collision name tx ty)
        (starts-with? name [toggle])            (toggle-on-collision name tx ty dir)
        (starts-with? name [key])               (do (key-on-collision name tx ty) (set-player-dir dir))
        (starts-with? name [turnstile-ew])      (turnstile-ew-on-collision name tx ty dir)
        (starts-with? name [turnstile-we])      (turnstile-we-on-collision name tx ty dir)
        (starts-with? name [turnstile-sn])      (turnstile-sn-on-collision name tx ty dir)
        (starts-with? name [turnstile-ns])      (turnstile-ns-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-ew]) (stop-turnstile-ew-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-we]) (stop-turnstile-we-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-sn]) (stop-turnstile-sn-on-collision name tx ty dir)
        (starts-with? name [stop-turnstile-ns]) (stop-turnstile-ns-on-collision name tx ty dir)
        (starts-with? name [slope-en])          (slope-en-on-collision name tx ty dir)
        (starts-with? name [slope-es])          (slope-es-on-collision name tx ty dir)
        (starts-with? name [slope-nw])          (slope-nw-on-collision name tx ty dir)
        (starts-with? name [slope-sw])          (slope-sw-on-collision name tx ty dir))))

(define pullable-on-collision [...] '(name [name] slot [slot] side [side]) (fn (name slot side)

    (select
        (starts-with? name [pullable-ensw-]) nil ; NOP
        (starts-with? name [pullable-e-])   (if (not (== side [r])) (return))
        (starts-with? name [pullable-en-])  (if (not (or (== side [r]) (== side [u]))) (return))
        (starts-with? name [pullable-ens-]) (if (not (or (== side [r]) (== side [u]) (== side [d]))) (return))
        (starts-with? name [pullable-enw-]) (if (not (or (== side [r]) (== side [u]) (== side [l]))) (return))
        (starts-with? name [pullable-es-])  (if (not (or (== side [r]) (== side [d]))) (return))
        (starts-with? name [pullable-esw-]) (if (not (or (== side [r]) (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-ew-])  (if (not (or (== side [r]) (== side [l]))) (return))
        (starts-with? name [pullable-n-])   (if (not (== side [u])) (return))
        (starts-with? name [pullable-ns-])  (if (not (or (== side [u]) (== side [d]))) (return))
        (starts-with? name [pullable-nsw-]) (if (not (or (== side [u]) (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-nw-])  (if (not (or (== side [u]) (== side [l]))) (return))
        (starts-with? name [pullable-s-])   (if (not (or (== side [d]))) (return))
        (starts-with? name [pullable-sw-])  (if (not (or (== side [d]) (== side [l]))) (return))
        (starts-with? name [pullable-w-])   (if (not (or (== side [l]))) (return)))

    (do
        (ensure-pullable-in-updatables  name slot)
        (= slot 'player-was-on-side side))))

(define ensure-pullable-in-updatables [...] '(name [name] slot [slot]) (fn (name slot)
    (for i in level-updatable-indices (if (== (nth 0 i) name) (return nil)))
    (+= level-updatable-indices name slot)))

(define move-pullable-from-to [move pullable] '(fx [fx] fy [fy] tx [tx] ty [ty]) (fn (fx fy tx ty)

        (define from-slot [slot at fx fy] (level-get-slot fx fy))

        (if (not (starts-with? (find from-slot 'name) [pullable-])) (abort [pullable expected]))

        (define to-slot [slot at tx ty] (level-get-slot tx ty))

        (if (== [] (find to-slot 'name))
            (do (level-move-slot fx fy tx ty)
                (= level-updatable-indices (find (level-get-slot tx ty) 'name) (level-get-slot tx ty))
                (animation-entity-set-position (find to-slot 'name)  (vector (* 16 tx) (* 16 ty) 0))
                ))))

(define move-pullable-up [...] '(x [x] y [y]) (fn (x y)
    (move-pullable-from-to x y x (- y 1))))

(define move-pullable-down [...] '(x [x] y [y]) (fn (x y)
    (move-pullable-from-to x y x (+ y 1))))

(define move-pullable-left [...] '(x [x] y [y]) (fn (x y)
    (move-pullable-from-to x y (- x 1) y)))

(define move-pullable-right [...] '(x [x] y [y]) (fn (x y)
    (move-pullable-from-to x y (+ x 1) y)))

(define reverse-side [...] '(side [side to reverse]) (fn (side)
    (select 
        (== [u] side) [d]
        (== [d] side) [u]
        (== [l] side) [r]
        (== [r] side) [l])))

(define move-player-to [move player] '(tx [tx] ty [ty]) (fn (tx ty)
    (if (are-coordinates-out-of-level tx ty)
        (level-restart)
        (if (== [] (find (level-get-slot tx ty) 'name))
            (do
                (level-move-slot player-x player-y tx ty)
                (= player-x tx)
                (= player-y ty)
                (animation-entity-set-position (find (get-player) 'name) (vector (* 16 tx) (* 16 ty) 0)))
             (do
                (define tmpDir [tmpDir] (find (get-player) 'dir))
                (= (get-player) 'dir nil)
                (on-collision tx ty tmpDir))))))

(define entity-new-player [entity-new-player] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [player-{}-{}] x y))
     (animation-entity-new id [player-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (= player-x x)
     (= player-y y)
     (= (get-player) 'name id)
     (= (get-player) 'x    x)
     (= (get-player) 'y    y)))

(define entity-new-wall [entity-new-wall] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [wall-{}-{}] x y))
     (animation-entity-new id [wall-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the wall to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stopper [entity-new-stopper] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [stopper-{}-{}] x y))
     (animation-entity-new id [stopper-idle] '((* 16 x) (* 16 y) -1))
     (define slot [slot at x y, the stopper] (make-empty-slot))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= level-updatable-indices id slot)))

(define entity-new-toggle [entity-new-toggle] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [toggle-{}-{}] x y))
     (animation-entity-new id [toggle-none-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the toggle] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-slope-en [entity-new-slope-en] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [slope-en-{}-{}] x y))
     (animation-entity-new id [slope-en-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the slope-en to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-slope-es [entity-new-slope-es] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [slope-es-{}-{}] x y))
     (animation-entity-new id [slope-es-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the slope-es to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-slope-nw [entity-new-slope-nw] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [slope-nw-{}-{}] x y))
     (animation-entity-new id [slope-nw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the slope-nw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-slope-sw [entity-new-slope-sw] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [slope-sw-{}-{}] x y))
     (animation-entity-new id [slope-sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the slope-sw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-turnstile-ew [entity-new-turnstile-ew] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [turnstile-ew-{}-{}] x y))
     (animation-entity-new id [turnstile-ew-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the turnstile-ew to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-turnstile-we [entity-new-turnstile-we] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [turnstile-we-{}-{}] x y))
     (animation-entity-new id [turnstile-we-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the turnstile-we to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-turnstile-sn [entity-new-turnstile-sn] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [turnstile-sn-{}-{}] x y))
     (animation-entity-new id [turnstile-sn-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the turnstile-sn to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-turnstile-ns [entity-new-turnstile-ns] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [turnstile-ns-{}-{}] x y))
     (animation-entity-new id [turnstile-ns-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the turnstile-ns to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stop-turnstile-ew [entity-new-stop-turnstile-ew] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [stop-turnstile-ew-{}-{}] x y))
     (animation-entity-new id [stop-turnstile-ew-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the stop-turnstile-ew to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stop-turnstile-we [entity-new-stop-turnstile-we] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [stop-turnstile-we-{}-{}] x y))
     (animation-entity-new id [stop-turnstile-we-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the stop-turnstile-we to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stop-turnstile-sn [entity-new-stop-turnstile-sn] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [stop-turnstile-sn-{}-{}] x y))
     (animation-entity-new id [stop-turnstile-sn-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the stop-turnstile-sn to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stop-turnstile-ns [entity-new-stop-turnstile-ns] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [stop-turnstile-ns-{}-{}] x y))
     (animation-entity-new id [stop-turnstile-ns-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the stop-turnstile-ns to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-exit [entity-new-exit] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [exit-{}-{}] x y))
     (animation-entity-new id [exit-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the exit to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-ensw [Add entity that can be pulled to up, down, left and right] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-ensw-{}-{}] x y))
     (animation-entity-new  id [pullable-ensw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-ensw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-e [Add entity that can be pulled to right] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-e-{}-{}] x y))
     (animation-entity-new  id [pullable-e----idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-e to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-en [Add entity that can be pulled to right and up] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-en-{}-{}] x y))
     (animation-entity-new  id [pullable-en---idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-en to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-ens [Add entity that can be pulled to right, up and down] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-ens-{}-{}] x y))
     (animation-entity-new  id [pullable-ens--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-ens to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-enw [Add entity that can be pulled to right, up and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-enw-{}-{}] x y))
     (animation-entity-new  id [pullable-en-w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-enw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-es [Add entity that can be pulled to right and down] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-es-{}-{}] x y))
     (animation-entity-new  id [pullable-e-s--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-es to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-esw [Add entity that can be pulled to right, down and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-esw-{}-{}] x y))
     (animation-entity-new  id [pullable-e-sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-esw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-ew [Add entity that can be pulled to right and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-ew-{}-{}] x y))
     (animation-entity-new  id [pullable-e--w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-ew to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-n [Add entity that can be pulled to up] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-n-{}-{}] x y))
     (animation-entity-new  id [pullable--n---idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-n to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-ns [Add entity that can be pulled to up and down] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-ns-{}-{}] x y))
     (animation-entity-new  id [pullable--ns--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-ns to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-nsw [Add entity that can be pulled to up, down and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-nsw-{}-{}] x y))
     (animation-entity-new  id [pullable--nsw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-nsw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-nw [Add entity that can be pulled to up and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-nw-{}-{}] x y))
     (animation-entity-new  id [pullable--n-w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-nw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-s [Add entity that can be pulled to down] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-s-{}-{}] x y))
     (animation-entity-new  id [pullable---s--idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-s to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-sw [Add entity that can be pulled to down and left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-sw-{}-{}] x y))
     (animation-entity-new  id [pullable---sw-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-sw to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pullable-w [Add entity that can be pulled to left] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [pullable-w-{}-{}] x y))
     (animation-entity-new  id [pullable----w-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the pullable-w to be] (level-get-slot x y))
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-stop-counter [entity-new-stop-counter] '(x [x-coordinate] y [y-coordinate] count [current count]) (fn (x y count)
     (define id [id] (string-format [stop-counter-{}-{}] x y))
     (animation-entity-new id (string-format [stop-counter-{}] count) '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the stop-counter to be] (level-get-slot x y))
     (= slot 'count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define entity-new-pass-counter [entity-new-pass-counter] '(x [x-coordinate] y [y-coordinate] count [current count]) (fn (x y count)
     (define id [id] (string-format [pass-counter-{}-{}] x y))
     (animation-entity-new id (string-format [pass-counter-{}] count) '((* 16 x) (* 16 y) 1))
     (define slot [slot at x y, the pass-counter to be] (make-empty-slot))
     (= slot 'count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= pass-counters id slot)))

(define pass-counter-decrease [decrease a pass counter] '(slot [slot for the pass counter]) (fn (slot)
    (define x             [x]             (find slot 'x))
    (define y             [y]             (find slot 'y))
    (define count         [count]         (find slot 'count))
    (define name          [name]          (find slot 'name))
    (define removePending [removePending] (find slot 'removePending))

    (if removePending (return))

    (if (== 1 count)
        (do
            (= slot 'removePending true)
            (pass-counter-update slot 0)
            (return nil)))

    (-- count)
    (= slot 'count count)
    (= slot 'decreasePending false)

    (animation-entity-remove name)

    (animation-entity-new
        name
        (string-format [pass-counter-{}] count)
        '((* 16 (find slot 'x)) (* 16 (find slot 'y)) 1))))

(define pass-counter-update [update a pass counter] '(slot [slot for the pass counter] dt [delta time]) (fn (slot dt)
    (define x               [x]    (find slot 'x))
    (define y               [y]    (find slot 'y))
    (define name            [name] (find slot 'name))
    (define decreasePending [tmp]  (find slot 'decreasePending))
    (define removePending   [tmp]  (find slot 'removePending))

    (if removePending
        (do
            (if (level-is-slot-empty? x y) (do
                (animation-entity-remove name)
                (-= pass-counters name)
                (entity-new-wall x y)))
            (return nil)))

    (if decreasePending
        (do
            (if (or (!= player-x x) (!= player-y y)) (pass-counter-decrease slot))
            (return nil)))

    (if (and (== player-x x) (== player-y y)) (= slot 'decreasePending true))))

(define entity-new-bomb [entity-new-bomb] '(x [x-coordinate] y [y-coordinate] count [current count]) (fn (x y count)
     (define id [id] (string-format [bomb-{}-{}] x y))
     (animation-entity-new id (string-format [bomb-{}] count) '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the bomb to be] (level-get-slot x y))
     (= slot 'count count)
     (= slot 'bomb-original-count count)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)
     (+= level-updatable-indices id slot)))

(define entity-new-key [Create new key] '(x [x-coordinate] y [y-coordinate]) (fn (x y)
     (define id [id] (string-format [key-{}-{}] x y))
     (animation-entity-new id [key-idle] '((* 16 x) (* 16 y) 0))
     (level-set-slot x y (make-empty-slot))
     (define slot [slot at x y, the key to be] (level-get-slot x y))
     (++ level-number-of-keys)
     (= slot 'name id)
     (= slot 'x    x)
     (= slot 'y    y)))

(define levels [levels] '(

    (fn ()
    ; Top row
    (entity-new-player -6 0)
    (entity-new-exit    6 0))

    (fn ()
    ; Top row
    (entity-new-player -6 0)
    (entity-new-key     0 0)
    (entity-new-exit    6 0))

    (fn ()
    ; Top row
    (entity-new-wall    -6 0)
    (entity-new-key     -5 0)
    (entity-new-player  -2 0)
    (entity-new-key      0 0)
    (entity-new-exit     6 0))

    (fn ()
    ; Top row
    (entity-new-wall          0 -5)
    (entity-new-stop-counter  2 -5 1)

    ; 2. row
    (entity-new-stop-counter -4 -4 1)
    (entity-new-stop-counter  4 -4 1)

    ; 3. row
    (entity-new-wall         -1 -3)
    (entity-new-wall          1 -3)

    ; 4. row
    (entity-new-stop-counter -5 -2 1)
    (entity-new-key          -2 -2)
    (entity-new-wall         -1 -2)
    (entity-new-wall          1 -2)
    (entity-new-key           2 -2)

    ; 5. row
    (for i from -3 to -1 (entity-new-wall i -1))
    (for i from  1 to  3 (entity-new-wall i -1))

    ; 6. row
    (entity-new-wall         -5 0)
    (entity-new-player        0 0)
    (entity-new-wall          5 0)

    ; 7. row
    (for i from -3 to -1 (entity-new-wall i 1))
    (for i from  1 to  3 (entity-new-wall i 1))

    ; 8. row
    (entity-new-stop-counter  5  2 1)
    (entity-new-key          -2  2)
    (entity-new-wall         -1  2)
    (entity-new-wall          1  2)
    (entity-new-key           2  2)

    ; 9. row
    (entity-new-wall         -1  3)
    (entity-new-wall          1  3)

    ; 10. row
    (entity-new-stop-counter -4  4 1)
    (entity-new-stop-counter  4  4 1)

    ; Last row
    (entity-new-exit         -4  5)
    (entity-new-stop-counter -2  5 1)
    (entity-new-wall          0  5))



    (fn ()
    ; Top row
    (entity-new-slope-es   0 -4)
    (entity-new-slope-sw   5 -4)

    ; 2. row
    ;-

    ; 3. row
    (entity-new-bomb      -4 -2 7)

    ; 4. row
    (entity-new-exit         -6 -1)
    (entity-new-turnstile-ns -3 -1)
    (entity-new-player        0 -1)
    (entity-new-pass-counter  5 -1 2)

    ; 5. row
    (entity-new-wall          3 0)

    ; 6. row
    (entity-new-wall         -2 1)

    ; 7. row
    (entity-new-wall         -5 2)
    (entity-new-wall          2 2)

    ; 8. row
    (entity-new-key          -3 3)

    ; 9. row
    (entity-new-wall         -3 4)
    (entity-new-slope-en      0 4)
    (entity-new-slope-nw      5 4)

    ; 10. row
    (entity-new-wall         -1 5))



    (fn ()
    ; Top row
    (entity-new-wall      -7  -7)

    ; 2. row
    (entity-new-wall      -2  -6)
    (entity-new-key       -1  -6)
    (entity-new-slope-sw   2  -6)

    ; 3. row
    (entity-new-wall       5  -5)

    ; 4. row
    (entity-new-wall      -5  -4)
    (entity-new-wall      -4  -4)
    (entity-new-wall       0  -4)
    (entity-new-wall       1  -4)

    ; 5. row
    (entity-new-wall          -6  -3)
    (entity-new-key           -4  -3)
    (entity-new-turnstile-we  -3  -3)
    (entity-new-turnstile-ns  -1  -3)
    (entity-new-key            0  -3)
    (entity-new-wall           2  -3)

    ; 6. row
    (entity-new-slope-es      -8  -2)
    (entity-new-turnstile-ew  -6  -2)
    (entity-new-wall          -2  -2)
    (entity-new-turnstile-we   2  -2)
    (entity-new-turnstile-we   4  -2)
    (entity-new-bomb           6  -2 10)

    ; 7. row
    (entity-new-wall          -6  -1)
    (entity-new-wall           2  -1)
    (entity-new-exit           8  -1)

    ; 8. row
    (entity-new-wall          -6   0)
    (entity-new-wall           2   0)

    ; 9. row
    (entity-new-wall          -8   1)
    (entity-new-wall          -5   1)
    (entity-new-wall           1   1)
    (entity-new-slope-nw       6   1)

    ; 10. row
    (entity-new-wall          -4   2)
    (entity-new-wall          -0   2)

    ; 11. row
    (entity-new-wall          -7   3)
    (entity-new-wall          -3   3)
    (entity-new-wall          -1   3)
    (entity-new-wall           3   3)

    ; 12. row
    (entity-new-turnstile-sn  -2   4)

    ; 13. row
    (entity-new-wall           1   5)

    ; 14. row
    (entity-new-wall          -5   6)

    ; Bottom row
    (entity-new-player        -8   7)
    (entity-new-wall          -1   7))



    (fn ()
    ; top row
    (for i from -8 to 0 (entity-new-wall i -6))

    ; next row
    (entity-new-wall   -8 -5)
    (entity-new-player -7 -5)
    (for i from 0 to 7 (entity-new-wall  i -5))

    ; Third row from top
    (entity-new-wall -8 -4)
    (entity-new-wall  7 -4)

    ; Fourth row from top
    (entity-new-wall -8 -3)
    (entity-new-pullable-ensw 6 -3)
    (entity-new-wall  7 -3)

    ; Fifth
    (entity-new-wall -8 -2)
    (entity-new-wall -5 -2)
    (entity-new-wall -4 -2)
    (for i from -3 to -1 (entity-new-pullable-ensw i -2))
    (entity-new-wall 0 -2)
    (entity-new-wall 1 -2)
    (entity-new-pullable-ensw 2 -2)
    (entity-new-wall 3 -2)
    (entity-new-wall 4 -2)
    (entity-new-wall 7 -2)

    ; Sixth
    (entity-new-wall -8 -1)
    (entity-new-wall -5 -1)
    (entity-new-wall -4 -1)
    (entity-new-pullable-ensw -3 -1)
    (entity-new-pullable-ensw -2 -1)
    (for i from -1 to 1 (entity-new-wall i -1))
    (entity-new-pullable-ensw 2 -1)
    (entity-new-wall 3 -1)
    (entity-new-wall 4 -1)
    (entity-new-wall 7 -1)

    ; Seventh
    (entity-new-wall -8 0)
    (entity-new-wall -5 0)
    (entity-new-wall -4 0)
    (for i from -3 to 2 (entity-new-pullable-ensw i 0))
    (entity-new-wall 3 0)
    (entity-new-wall 4 0)
    (entity-new-wall 7 0)

    ; Eight
    (entity-new-wall -8 1)
    (entity-new-wall -5 1)
    (entity-new-wall -4 1)
    (entity-new-pullable-ensw -3 1)
    (entity-new-pullable-ensw -2 1)

    (entity-new-exit  0 1)

    (entity-new-pullable-ensw 2 1)
    (entity-new-wall 3 1)
    (entity-new-wall 4 1)
    (entity-new-wall 7 1)

    ; Ninth
    (entity-new-wall -8 2)
    (entity-new-wall -5 2)
    (entity-new-wall -4 2)
    (entity-new-pullable-ensw -3 2)
    (entity-new-pullable-ensw -2 2)
    (for i from -1 to 1 (entity-new-wall i 2))
    (entity-new-pullable-ensw 2 2)
    (entity-new-wall 3 2)
    (entity-new-wall 4 2)
    (entity-new-wall 7 2)

    ; Tenth
    (entity-new-wall -8 3)
    (entity-new-pullable-ensw  6 3)
    (entity-new-wall  7 3)

    ; Eleventh
    (entity-new-wall -8 4)
    (entity-new-wall -7 4)
    (entity-new-wall  7 4)

    ; Bottom row
    (for i from -7 to 7 (entity-new-wall i 5)))



    (fn ()
    ; Top row
    (entity-new-exit          0  -9)

    (for i from -7 to 7 (entity-new-pullable-ensw i  -7))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -6))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -5))

    (for i from -7 to 7 (entity-new-pullable-ensw i  -4))

    (for i from -7 to -2 (entity-new-pullable-ensw i  -3))
    (for i from  2 to  7 (entity-new-pullable-ensw i  -3))

    (for i from -7 to -3 (entity-new-pullable-ensw i  -2))
    (for i from  3 to  7 (entity-new-pullable-ensw i  -2))

    (for i from -7 to -4 (entity-new-pullable-ensw i  -1))
    (for i from  4 to  7 (entity-new-pullable-ensw i  -1))

    (entity-new-exit -9 0)
    (for i from -7 to -4 (entity-new-pullable-ensw i   0))
    (entity-new-player 0 0)
    (for i from  4 to  7 (entity-new-pullable-ensw i   0))
    (entity-new-exit  9 0)

    (for i from -7 to -4 (entity-new-pullable-ensw i   1))
    (for i from  4 to  7 (entity-new-pullable-ensw i   1))

    (for i from -7 to -3 (entity-new-pullable-ensw i   2))
    (for i from  3 to  7 (entity-new-pullable-ensw i   2))

    (for i from -7 to -2 (entity-new-pullable-ensw i   3))
    (for i from  2 to  7 (entity-new-pullable-ensw i   3))

    (for i from -7 to  7 (entity-new-pullable-ensw i   4))

    (for i from -7 to  7 (entity-new-pullable-ensw i   5))

    (for i from -7 to  7 (entity-new-pullable-ensw i   6))

    (for i from -7 to  7 (entity-new-pullable-ensw i   7))

    (entity-new-exit 0 9))



    (fn ()
    ; Top row
    (for i from -6 to 6 (entity-new-stopper i  -6))

    ; 2. row
    (entity-new-stopper -6 -5)
    (entity-new-stopper  6 -5)

    ; 3. row
    (entity-new-stopper -6 -4)
    (for i from -4 to -2 (entity-new-pullable-ensw i -4))
    (for i from  2 to  4 (entity-new-pullable-ensw i -4))
    (entity-new-stopper  6 -4)

    ; 4. row
    (entity-new-stopper -6 -3)
    (entity-new-pullable-ensw -4 -3)
    (entity-new-toggle        -3 -3)
    (entity-new-pullable-ensw -2 -3)
    (entity-new-pullable-ensw -1 -3)
    (entity-new-pullable-ensw  1 -3)
    (entity-new-pullable-ensw  2 -3)
    (entity-new-toggle         3 -3)
    (entity-new-pullable-ensw  4 -3)
    (entity-new-stopper  6 -3)

    ; 5. row
    (entity-new-stopper -6 -2)
    (for i from  -4 to 4 (entity-new-pullable-ensw i -2))
    (entity-new-stopper  6 -2)

    ; 6. row
    (entity-new-stopper -6 -1)
    (for i from  -3 to 3 (entity-new-pullable-ensw i -1))
    (entity-new-stopper  6 -1)

    ; 7. row
    (entity-new-stopper -6 0)
    (entity-new-pullable-ensw -2 0)
    (entity-new-pullable-ensw -1 0)
    (entity-new-exit           0 0)
    (entity-new-pullable-ensw  1 0)
    (entity-new-pullable-ensw  2 0)
    (entity-new-stopper  6 0)

    ; 8. row
    (entity-new-stopper -6 1)
    (for i from  -3 to 3 (entity-new-pullable-ensw i 1))
    (entity-new-stopper  6 1)

    ; 9. row
    (entity-new-stopper -6 2)
    (for i from  -4 to 4 (entity-new-pullable-ensw i 2))
    (entity-new-stopper  6 2)

    ; 10. row
    (entity-new-stopper -6       3)
    (entity-new-pullable-ensw -4 3)
    (entity-new-toggle        -3 3)
    (entity-new-pullable-ensw -2 3)
    (entity-new-pullable-ensw -1 3)
    (entity-new-pullable-ensw  1 3)
    (entity-new-pullable-ensw  2 3)
    (entity-new-toggle         3 3)
    (entity-new-pullable-ensw  4 3)
    (entity-new-stopper        6 3)

    ; 11. row
    (entity-new-stopper -6 4)
    (for i from -4 to -2 (entity-new-pullable-ensw i 4))
    (for i from  2 to  4 (entity-new-pullable-ensw i 4))
    (entity-new-stopper  6 4)

    ; 12. ro
    (entity-new-stopper -6 5)
    (entity-new-stopper  6 5)

    ; 13. row
    (for i from -6 to 6 (entity-new-stopper i  6))

    ; Bottom row
    (entity-new-player      0   8))



    (fn ()
    ; Top row
    (for i from -6 to 6 (entity-new-wall i -6))

    ; 2. row
    (entity-new-wall -6 -5)
    (for i from -5 to 5 (entity-new-stopper i -5))
    (entity-new-wall  6 -5)

    ; 3 - 5. row
    (for i from -4 to -2
        (entity-new-wall    -6 i)
        (entity-new-stopper -5 i)
        (entity-new-stopper  5 i)
        (entity-new-wall     6 i))

    ; 6. row
    (entity-new-wall    -6 -1)
    (entity-new-stopper -5 -1)
    (for i from -3 to 3 (entity-new-pullable-ensw i -1))
    (entity-new-stopper  5 -1)
    (entity-new-wall     6 -1)

    ; 7. row
    (entity-new-wall    -6 0)
    (entity-new-stopper -5 0)
    (for i from -3 to 3 step 2 (entity-new-pullable-ensw i 0))
    (for i from -2 to 2 step 2 (entity-new-toggle        i 0))
    (entity-new-stopper  5 0)
    (entity-new-wall     6 0)

    ; 8. row
    (entity-new-wall    -6 1)
    (entity-new-stopper -5 1)
    (for i from -3 to 3 (entity-new-pullable-ensw i 1))
    (entity-new-stopper  5 1)
    (entity-new-wall     6 1)

    ; 9 - 11. row
    (for i from 2 to 4
        (entity-new-wall    -6 i)
        (entity-new-stopper -5 i)
        (entity-new-stopper  5 i)
        (entity-new-wall     6 i))

    (entity-new-player       4 4)

    ; 12. row
    (entity-new-wall -6 5)
    (for i from -5 to 5 (entity-new-stopper i 5))
    (entity-new-wall  6 5)

    ; Bottom row
    (for i from -6 to -1 (entity-new-wall i 6))
    (entity-new-exit 0 6)
    (for i from  1 to  6 (entity-new-wall i 6)))



    (fn ()
    ; Top row
    (entity-new-wall 1 -8)

    ; 2. row
    (entity-new-wall -3 -7)
    (entity-new-key  -1 -7)

    ; 5. row
    (entity-new-wall -6 -4)

    ; 6. row
    (entity-new-wall -7 -3)
    (entity-new-wall  2 -3)
    (entity-new-wall  6 -3)

    ; 7. row
    (entity-new-wall -5 -2)

    ; 8.row
    (entity-new-wall -7 -1)
    (entity-new-wall -4 -1)

    ; 9. row
    (entity-new-key         -7 0)
    (entity-new-wall        -6 0)
    (entity-new-wall        -3 0)
    (entity-new-pass-counter 4 0 1)
    (entity-new-wall         5 0)
    (entity-new-exit         8 0)

    ; 10. row
    (entity-new-wall        -8 1)
    (entity-new-wall        -5 1)
    (entity-new-wall        -2 1)
    (entity-new-pass-counter 6 1 3)

    ; 11. row
    (entity-new-wall        -7 2)
    (entity-new-wall        -4 2)
    (entity-new-wall        -1 2)
    (entity-new-wall         1 2)
    (entity-new-stop-counter 7 2 1)

    ; 12. row
    (entity-new-wall        -6 3)
    (entity-new-wall        -3 3)
    (entity-new-wall         0 3)
    (entity-new-pass-counter 3 3 3)
    (entity-new-wall         5 3)
    (entity-new-wall         6 3)

    ; 13. row
    (entity-new-wall        -5 4)
    (entity-new-wall        -2 4)
    (entity-new-key         -1 4)

    ; 14. row
    (entity-new-wall        -4 5)
    (entity-new-wall        -1 5)
    (entity-new-wall         0 5)

    ; 15. row
    (entity-new-wall        -3 6)
    (entity-new-wall         4 6)

    ; 16. row
    (entity-new-wall        -2 7)
    (entity-new-wall         0 7)
    (entity-new-wall         2 7)

    ; 17. row
    (entity-new-wall         0 8)
    (entity-new-player       7 8))



    (fn ()
    ; Top row
    (for i from -7 to -3 (entity-new-wall i -4))
    (for i from -1 to  1 (entity-new-wall i -4))

    ; 2. row
    (entity-new-wall -7 -3)
    (entity-new-wall  0 -3)

    ; 3. row
    (entity-new-wall         -7 -2  )
    (entity-new-wall          0 -2  )
    (entity-new-pass-counter  1 -2 2)

    ; 4. row
    (entity-new-exit         -8 -1  )
    (entity-new-pass-counter -3 -1 4)
    (entity-new-turnstile-ew  0 -1  )
    (entity-new-pass-counter  4 -1 2)
    (entity-new-slope-sw      6 -1  )

    ; 5. row
    (entity-new-wall         -6 0)
    (entity-new-player       -5 0)
    (entity-new-wall          0 0)
    (entity-new-wall          8 0)

    ; 6. row
    (entity-new-wall         -6 1  )
    (entity-new-turnstile-we  0 1  )
    (entity-new-stop-counter  3 1 4)
    (entity-new-slope-nw      6 1  )

    ; 7. row
    (entity-new-wall         -6 2  )
    (entity-new-pass-counter -4 2 1)

    ; 8. row
    (entity-new-wall         -6 3  )
    (entity-new-stop-counter -2 3 1)
    (entity-new-wall          0 3  )
    (entity-new-key           7 3  )

    ; Last row
    (entity-new-wall         -6 4 )
    (entity-new-wall         -5 4 )
    (entity-new-wall          0 4 )
    (entity-new-stop-counter  1 4 1)
    (entity-new-wall          7 4 ))



    (fn ()
    ; Top row
    (entity-new-wall     -7  -6)
    (entity-new-wall     -6  -6)
    (entity-new-slope-es  0  -6)
    (entity-new-slope-sw  5  -6)

    ; 2. row
    (entity-new-key      -7  -5)
    (entity-new-key      -6  -5)

    ; 3. row
    (entity-new-wall         -5  -4)
    (entity-new-pass-counter -3  -4  1)
    (entity-new-key           0  -4)
    (entity-new-pullable-w    1  -4)
    (for x from 2 to 4 (entity-new-wall x -4))

    ; 4. row
    (entity-new-turnstile-we 0 -3)
    (entity-new-turnstile-we 4 -3)
    (entity-new-key          6 -3)
    (entity-new-slope-sw     7 -3)

    ; 5. row
    (entity-new-pass-counter -6  -2  2)
    (entity-new-wall         -1  -2)
    (entity-new-wall          0  -2)
    (entity-new-turnstile-ns  1  -2)
    (entity-new-wall          4  -2)

    ; 6. row
    (entity-new-key  -5 -1)
    (entity-new-wall -4 -1)
    (entity-new-wall  0 -1)
    (entity-new-wall  4 -1)

    ; 7. row
    (entity-new-pullable-nw 4 0)
    (entity-new-slope-nw    5 0)

    ; 8. row
    (entity-new-pullable-n  1 1)
    (for x from 2 to 4 (entity-new-wall x 1))

    ; 9. row
    (entity-new-slope-en -7 2)
    (entity-new-key      -1 2)
    (entity-new-slope-sw  6 2)

    ; 10. row
    (entity-new-pass-counter -6 3 4)
    (entity-new-turnstile-ns  7 3)

    ; 11. row
    (entity-new-wall -7 4)

    ; 12. row
    (entity-new-wall    -6 5)
    (entity-new-exit    -5 5)
    (entity-new-player   0 5)
    (entity-new-slope-nw 6 5)
    (entity-new-wall     7 5))



    (fn ()
    ; Top to fifth rows
    (for y from -8 to -4
         (for x from -8 to 8 (entity-new-pullable-ensw x y)))

    ; 6. row
    (for x from -8 to -2 (entity-new-pullable-ensw x -3))
    (for x from  2 to  8 (entity-new-pullable-ensw x -3))

    ; 7. row
    (for x from -8 to -3 (entity-new-pullable-ensw x -2))
    (for x from  3 to  8 (entity-new-pullable-ensw x -2))

    ; 8. row
    (entity-new-exit -10 -1)
    (for x from -8 to -4 (entity-new-pullable-ensw x -1))
    (for x from  4 to  8 (entity-new-pullable-ensw x -1))

    ; 9. row
    (for x from -8 to -4 (entity-new-pullable-ensw x  0))
    (entity-new-player 0  0)
    (for x from  4 to  8 (entity-new-pullable-ensw x  0))

    ; 10. row
    (for x from -8 to -4 (entity-new-pullable-ensw x  1))
    (for x from  4 to  8 (entity-new-pullable-ensw x  1))

    ; 11. row
    (for x from -8 to -3 (entity-new-pullable-ensw x  2))
    (for x from  3 to  8 (entity-new-pullable-ensw x  2))

    ; 12. row
    (for x from -8 to -2 (entity-new-pullable-ensw x  3))
    (for x from  2 to  8 (entity-new-pullable-ensw x  3))

    ; Five bottom rows
    (for y from 4 to 8
         (for x from -8 to 8 (entity-new-pullable-ensw x y))))


    (fn ()
    ; Top row
    (entity-new-slope-es -5 -6)
    (entity-new-bomb     -1 -6 7)

    ; 3. row
    (entity-new-wall      3 -4)
    (entity-new-wall      4 -4)

    ; 4. row
    (entity-new-wall         -3 -3)
    (entity-new-pass-counter  0 -3 1)
    (entity-new-player        3 -3)
    (entity-new-slope-sw      7 -3)

    ; 6. row
    (entity-new-turnstile-ns  7 -1)

    ; 7. row
    (entity-new-bomb -5 0 5)
    (entity-new-pass-counter -2 0 2)
    (entity-new-slope-nw 3 0)

    ; 8. row
    (entity-new-wall -7 1)
    (entity-new-key  -6 1)
    (entity-new-wall -4 1)
    (entity-new-wall  6 1)
    (entity-new-exit  7 1)

    ; 10. row
    (entity-new-pass-counter -1 3 3)

    ; 11. row
    (entity-new-slope-en -5 4)

    ; 12. row
    (entity-new-wall -1 5))
))


(define number-of-levels [number of levels] '() (fn () (len levels)))

(define level-load [load level from vector index] '(levelNumber [1..n]) (fn (levelNumber)
    (define f [f] (nth (- levelNumber 1) levels))
    ((eval f))
    (= level-current-number levelNumber)
))

(define level-restart [restart level] '() (fn ()
    (level-reset)

    (define lnum [level number before change] level-current-number)

    (level-load lnum)

    (shake)))

(define level-prev [previous level] '() (fn ()
    (level-reset)

    (define lnum [level number] (- level-current-number 1))

    (if (< lnum 1) (= lnum (number-of-levels)))

    (level-load lnum)))

(define level-next [next level] '() (fn ()
    (level-reset)

    (define lnum [level number] (+ level-current-number 1))

    (if (> lnum (number-of-levels)) (= lnum 1))

    (level-load lnum)))

(define current-state [current-state] [game])
(define pending-input [pending input that is not yet handled] '())

(define pop-input [pop input] '() (fn ()

    (define result [result] [])

    (if (!= 0 (len pending-input))
        (do
            (= result (nth 0 pending-input))
            (pop-front pending-input)))

    result))

(define printlevel [printlevel] false)

(define bomb-update [update a bomb] '(slot [slot for the bomb] dt [delta time]) (fn (slot dt)
    (if (not (find slot 'bomb-started)) (return nil))
    (+= (find slot 'bomb-uptime) dt)

    (if (>= (find slot 'bomb-uptime) (find slot 'bomb-original-count)) (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y)))

    (define tmpSecs [tmp secs] (- (find slot 'bomb-original-count) (to-integer (find slot 'bomb-uptime))))

    (define curSecs [curret secs] (find slot 'count))
    (if (== curSecs 0) (do (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y) (return true))))
    (if (== tmpSecs 0) (do (bomb-remove (find slot 'name) (find slot 'x) (find slot 'y) (return true))))

    (if (< tmpSecs curSecs) (do
                                (= slot 'count tmpSecs)
                                (animation-entity-remove (find slot 'name))
                                (animation-entity-new
                                    (find slot 'name)
                                    (string-format [bomb-{}] tmpSecs)
                                    '((* 16 (find slot 'x)) (* 16 (find slot 'y)) 0))))
))

(define stopper-update [update a stopper] '(slot [slot for the stopper] dt [delta time]) (fn (slot dt)
    (if (!= player-x (find slot 'x)) (return nil))
    (if (!= player-y (find slot 'y)) (return nil))
    (set-player-dir nil)))

(define pullable-anytype-update [update a any pullable type] '(slot [slot for the entity] dt [delta time]) (fn (slot dt)
    (define px  [px] (find slot 'x))
    (define py  [py] (find slot 'y))

    (define currentSide [current side]
        (coords-to-side px py player-x player-y))

    (= currentSide (reverse-side currentSide))

    (if (!= currentSide (find slot 'player-was-on-side))
        (do (-= level-updatable-indices (find slot 'name)) (return nil)))

    (select
        (== currentSide [u]) (move-pullable-up    px py)
        (== currentSide [d]) (move-pullable-down  px py)
        (== currentSide [l]) (move-pullable-left  px py)
        (== currentSide [r]) (move-pullable-right px py))))


(define state-update-game [state-update]
                     '(dt [delta time]
                       input [string telling the input, if any: u, d, l, r]) (fn (dt input)

    (select
        (== input [restart])   (do (= input []) (level-restart))
        (== input [prevLevel]) (do (= input []) (level-prev))
        (== input [nextLevel]) (do (= input []) (level-next))
        (== input [action 1])  (do (= input []) (= printlevel (not printlevel))))

    (if (!= input []) (+= pending-input input))

    (if (== nil player-x)     (return nil))
    (if (== nil player-y)     (return nil))
    (if (== nil (get-player)) (return nil))

    (if (== (find (get-player) 'dir) nil)
        (do
            (= input (pop-input))
            (select
                (== input [up])       (= (get-player) 'dir [u])
                (== input [down])     (= (get-player) 'dir [d])
                (== input [left])     (= (get-player) 'dir [l])
                (== input [right])    (= (get-player) 'dir [r]))))

    (define player-dir [player-dir] (find (get-player) 'dir))

    (select
        (== player-dir [u]) (move-player-to player-x       (- player-y 1))
        (== player-dir [d]) (move-player-to player-x       (+ player-y 1))
        (== player-dir [l]) (move-player-to (- player-x 1) player-y)
        (== player-dir [r]) (move-player-to (+ player-x 1) player-y))

    (if pass-or-fail-level-pending (do (pass-or-fail-level) (return true)))

    (define tmpPassCounters [prevent problems of modifying during iteration] nil)
    (= tmpPassCounters pass-counters)
    (for i in tmpPassCounters
        (pass-counter-update (nth 1 i) dt))

    (define tmpLUI [prevent problems of modifying during iteration] nil)
    (= tmpLUI level-updatable-indices)
    (for i in tmpLUI
        (define zeroth [zeroth] (nth 0 i))
        (select
            (starts-with? zeroth [bomb])          (bomb-update             (nth 1 i) dt)
            (starts-with? zeroth [stopper])       (stopper-update          (nth 1 i) dt)
            (starts-with? zeroth [pullable-])     (pullable-anytype-update (nth 1 i) dt)))

    true))

(define state-update-tween-out [state-update]
                     '(dt [delta time]
                       input [string telling the input, if any: u, d, l, r]) (fn (dt input)
    true))

(define state-update [state-update]
                     '(dt [delta time]
                       input [string telling the input, if any: u, d, l, r]) (fn (dt input)

    (if (> level-restart-pending 0)
      (do
        (-- level-restart-pending)
        (if (== level-restart-pending 0)
          (do
            (= level-restart-pending -1)
            (level-restart)
            (return true))
          (return true))))

    (select
        (== [game]     current-state) (state-update-game      dt input)
        (== [tweenOut] current-state) (state-update-tween-out dt input))

    (if printlevel (level-print))

    true))


(define state-on-tween-out-done [...] '() (fn ()
    ;(message-show 0)
    (level-next)))

(define state-on-tween-in-done [...] '() (fn ()
    (= current-state [game])))

; Game starts here
(level-load 1)



;;; Here are some helper functions for debugging purposes.
;;; Can be removed later

(define level-print-slot [...] '(x [x] y [y]) (fn (x y)
    (define name [name] (find (level-get-slot x y) 'name))
    (if (== [] name)                         (do (print [  ]) (return nil)))
    (if (starts-with? name [exit])           (do (print [EX]) (return nil)))
    (if (starts-with? name [player])         (do (print [:)]) (return nil)))
    (if (starts-with? name [wall])           (do (print [XX]) (return nil)))
    (if (starts-with? name [pullable])       (do (print [PP]) (return nil)))
    (if (starts-with? name [stop-counter])   (do (print [$$]) (return nil)))
    (if (starts-with? name [key])            (do (print [|bar||bar|]) (return nil)))
    (if (starts-with? name [bomb])           (do (print [!!]) (return nil)))
    (if (starts-with? name [slope-en])       (do (print [^_]) (return nil)))
    (if (starts-with? name [slope-es])       (do (print [|bar|']) (return nil)))
    (if (starts-with? name [slope-sw])       (do (print ['|bar|]) (return nil)))
    (if (starts-with? name [slope-nw])       (do (print [_|bar|]) (return nil)))
    (if (starts-with? name [toggle])         (do (print [TT])     (return nil)))
    (if (starts-with? name [turnstile])      (do (print [::])     (return nil)))
    (if (starts-with? name [stop-turnstile]) (do (print [;;])     (return nil)))
    (print name)))

(define level-print-row [...] '(y [y]) (fn (y)
    (for x from (- level-hwidth) to (- level-hwidth 1) (level-print-slot x y))
    (println [])))

(define level-print [...] '() (fn ()
    (println [-------------------------------------------------])
    (for y from (- level-hwidth) to (- level-hwidth 1) (level-print-row y))
    (println [-------------------------------------------------])))


(define level-print-slot-id [...] '(x [x] y [y]) (fn (x y)
    (define name [name] (find (level-get-slot x y) 'name))
    (print name)

    (define spaces [...] (- 18 (len name)))
    (for i from 0 to spaces (print [ ]))))

(define level-print-row-id [...] '(y [y]) (fn (y)
    (for x from (- level-hwidth) to (- level-hwidth 1) (level-print-slot-id x y))
    (println [])))

(define level-print-id [...] '() (fn ()
    (for y from (- level-hwidth) to (- level-hwidth 1) (level-print-row-id y))))


